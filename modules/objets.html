<module title="Programmation Orientée Objets"
with-contents="true"
ocaml-session="objets"
>
<contents>
<section counter="false" id="preambule" title="Préambule">
<p>Ce document n'est <strong>pas</strong> une introduction au
paradigme de la programmation objets, mais présente la
programmation orientée objets <strong>en OCaml</strong>. On suppose
donc que les notions de classes, objets, méthodes, héritage, etc.,
sont déjà connues.
</p>
</section>

<section id="introduction" title="Introduction">
<p>
OCaml s'appelait auparavant <i>Objective</i>-Caml, indiquant ainsi
qu'il comporte la possibilité de programmation orientée objets.
</p>
<p>
Cela signifie que le système de types permet de définir des types
pour les objets. La définition d'une classe entraîne la création
d'un type (de même nom). L'instanciation d'une classe crée donc
une valeur du type correspondant à la classe.
</p>
<p>
Comme les autres types, les types de classes peuvent également
être paramétrés (cf. <doc href="fonctionnelle#decltypes">cette section</doc>).
</p>
<p>
La notion de type pour les classes s'accompagne de la notion
de sous-typage, ou <em>polymorphisme d'inclusion</em>. Ainsi, un objet
A dont le type est un sous-type
d'un autre objet B pourra être utilisé en lieu et place de B.
Une relation de sous-typage est typiquement engendrée par
héritage, comme dans d'autres langages, mais nous verrons
qu'elle est indépendante et que c'est un aspect intéressant
du langage.
</p>
<p>
L'une des limites d'OCaml est l'impossibilité de surcharger<note>Par surcharge,
nous entendons la définition d'une nouvelle méthode avec le
même nom qu'une autre méthode, mais avec un type différent.
Nous employons le terme <em>surcharge</em> comme traduction du terme
<em>overload</em> et nous parlerons de <em>redéfinition</em>
pour traduire <em>override</em>, qui est la définition d'une méthode
dans une classe héritant d'une autre classe où la même méthode avec
le même type est déjà définie.</note> les
méthodes d'une classe, pour la même raison qu'il est impossible
de surcharger les opérateurs: il ne serait alors plus possible
d'inférer automatiquement le type des expressions.
</p>
</section>

<section id="objects" title="Objets">
<p>
Nous commençons par voir comment créer et manipuler des objets,
sans créer de classe. Par la suite, nous verrons comment créer
des classes et les instancier.
</p>
<subsection id="creatingobjects" title="Création d'objets">
<p>
La création d'un objet se fait avec la syntaxe suivante:
</p>
<centerstx>object <stxid>champs</stxid> end</centerstx>
<p>
Les <stxid>champs</stxid> de la définition permettent de définir
pour l'objet ses héritages, attributs (ou variables d'instance),
méthodes, contraintes de types,
ainsi qu'un éventuel traitement à effectuer à l'initialisation.
</p>
<p>Le code suivant déclare un objet "vide", sans attribut ni méthode:</p>
<oc-eval>object end ;;</oc-eval>

<p>Créons maintenant un objet un peu plus utile avec une méthode <ml>add : int -> int</ml>,
et un attribut non modifiable <ml>foo : int</ml> initialisé à <ml>1</ml>:
</p>
<oc-eval>object
    val foo = 1
    method add x = x + foo
  end;;
</oc-eval>
<p>
Le toplevel nous indique que la valeur a un type objet (<ml>&lt;obj&gt;</ml>)
et liste les méthodes visibles entre <ml>&lt;</ml> et <ml>&gt;</ml>,
en l'occurrence la méthode <ml>add : int -> int</ml>. Lorsqu'elle sera
appelée avec un paramètre <ml>x</ml> entier, la méthode <ml>add</ml> retournera
la valeur du corps de la méthode, ici l'expression <ml>x + foo</ml>
(<doc href="fonctionnelle#Lavaleurderetourdunefonc">comme pour les fonctions</doc>).
</p>

<p>Lors de la création de l'objet, les expressions d'initialisation
des attributs ne peuvent faire appel aux valeurs d'autres attributs
de l'objet:
</p>
<oc-eval error-exc="false">
object
    val x = 1
    val y = x + 1
  end
</oc-eval>
<p>
Le code à l'intérieur d'un objet peut accéder aux attributs en utilisant
simplement leur identifiant. Ici nous définissons un attribut <ml>foo</ml>
et une méthode <ml>foo</ml>. Les attributs et méthodes sont dans deux espaces
de noms différents. La méthode <ml>foo</ml> utilise l'attribut <ml>foo</ml>:
</p>
<oc-eval>object
    val foo = 1
    method foo = foo
  end
</oc-eval>
<p>
Pour appeler une méthode de l'objet depuis l'intérieur de l'objet,
il faut donner un nom à l'objet dans lequel on est; cela se fait en indiquant un
identifiant entre parenthèses après le mot-clé <ml>object</ml>, ici <ml>self</ml>.
On peut alors appeler la méthode sur l'objet <ml>self</ml>:
</p>
<oc-eval><![CDATA[let o =
  object(self)
    (* Ne faîtes pas ça chez vous :-) *)
    method fact n =
      if n <= 0
        then 0
        else if n = 1
          then 1
          else n * self#fact (n-1)
  end;;
o#fact 5 ;;]]></oc-eval>
</subsection>

<subsection id="letobject" title="Utilisation d'objets">
<p>
L'utilisation d'un objet passe par l'appel de ses méthodes.
L'appel de méthode (aussi appelé <em>envoi de message</em>)
 se fait en utilisant l'opérateur <ml>#</ml> avec
à gauche un objet et à droite le nom de la méthode éventuellement suivi
des arguments:
</p>
<centerstx><stxid>identifiant</stxid> # <stxid>méthode</stxid> [<stxid>arguments</stxid>]</centerstx>
<p>Par exemple, nous créons un objet <ml>x</ml> et appelons la méthode
<ml>as_string</ml> de cet objet:
</p>
<oc-eval>let x = object method as_string = "hello world!" end;;
x#as_string ;;
</oc-eval>
<p>
Contrairement aux valeurs fonctionnelles (ou fonctions), qui doivent avoir
au moins un paramètre pour mériter ce nom et retarder l'évaluation jusqu'au
moment où un argument est donné, les méthodes sans paramètre ne sont évaluées
que lors de leur appel explicite via un objet. En fait, dans le code
généré, ce sont des fonctions qui prennent en premier paramètre l'objet
en question. La méthode <ml>as_string</ml> ci-dessus ne prend pas de paramètre
mais son corps n'est évalué que lorsqu'elle est appelée sur un objet,
c'est-à-dire, dans le code généré, quand un objet lui est passé en paramètre.
Lorsqu'on utilise la notation <ml>object(self) ... end</ml>, on donne justement
un nom à ce paramètre implicite qu'est l'objet, et on peut donc en appeler
des méthodes.
</p>
<warning id="valsnotaccessible" title="Les attributs ne sont pas accessibles à l'extérieur">
<p>
Les attributs d'un objet ne sont pas accessibles depuis l'extérieur de cet objet:
</p>
<oc-eval error-exc="false"> let objet = object val x = 3 end;;
objet#x ;;
objet.x ;;
</oc-eval>
<p>Il est nécessaire de fournir les accesseurs (méthodes d'accès) pour les attributs
auxquels on permet l'accès depuis l'extérieur de l'objet, c'est-à-dire des
méthodes se contentant de retourner le contenu d'un attribut. Par convention,
ces méthodes portent le même nom que l'attribut dont elles renvoient la valeur,
mais ce n'est pas obligatoire:
</p>
<oc-eval error-exc="false"> let objet = object val x = 3 method x = x end;;
objet#x ;;
</oc-eval>
</warning>

</subsection>

<subsection id="initializer" title="Exécution de code à l'initialisation">
<p>
Le mot-clé <ml>initializer</ml> permet de spécifier du code
qui sera exécuté à la création de l'objet.
Ce code est exécuté après initialisation de tous les attributs; il
peut donc accéder aux valeurs des attributs et appeler des méthodes
de l'objet (en donnant un nom à l'objet, ici encore <ml>self</ml>).
</p>
<oc-eval>let o =
  object(self)
    val message = "hello world!"
    method hello = print_endline message
    initializer
      self#hello
  end;;
o#hello;;
</oc-eval>
</subsection>

<subsection id="mutablefields" title="Attributs mutables">
<p>
Par défaut, un attribut n'est pas modifiable. Mais, de la même façon que
pour <doc href="imperative#mutrecords">les types enregistrements</doc>,
le mot-clé <ml>mutable</ml> permet d'avoir des attributs modifiables par
le code à l'intérieur de l'objet. La modification d'un attribut
est réalisée, comme pour les champs d'enregistrements, avec l'opérateur
<ml>&lt;-</ml>:
</p>
<oc-eval><![CDATA[let o =
  object
    val mutable cpt = 0
    method incr = cpt <- cpt + 1
    method print = print_endline (string_of_int cpt)
  end;;
o#incr ;;
o#incr ;;
o#print ;;
]]></oc-eval>
<p>
Le compilateur signale une erreur si on tente de modifier un attribut
non modifiable:
</p>
<oc-eval error-exc="false"><![CDATA[object
  val cpt = 0
  method incr = cpt <- cpt + 1
end;;]]></oc-eval>
</subsection>


<subsection id="privatemethodes" title="Méthodes privées">
<p>
Le mot-clé <ml>private</ml> permet d'indiquer qu'une méthode est privée,
c'est-à-dire qu'elle ne peut être appelée que depuis une autre méthode de
la classe (ou dans la section <ml>initializer</ml>). Le type inféré
pour l'objet ne comporte pas les méthodes privées, qui sont donc bien
inaccessibles depuis l'extérieur de l'objet:
</p>
<oc-eval error-exc="false">let o =
  object(self)
    method private value = 42
    method as_string = string_of_int self#value
  end;;
o#as_string ;;
o#value ;;
</oc-eval>
</subsection>

</section>

<section id="funobject" title="Compatibilité des objets, sous-typage">
<p>
Un objet étant une valeur comme une autre, il peut être passé à ou renvoyé
par une fonction.
</p>
<p>
Le système de types fera les inférences et vérifications nécessaires pour
s'assurer qu'un objet n'est pas passé là où son type ne correspond pas à ce qui
est attendu. De même, une expression ne pourra renvoyer un objet avec un type
ne correspondant pas aux contraintes locales (par exemple deux objets
de types incompabibles en résultat des deux branches d'une conditionnelle).
</p>
<p>Voyons quelques exemples.</p>
<p>Commençons par définir une fonction qui retournera un objet comportant
une unique méthode <ml>print : string -> unit</ml>. Si le paramètre <ml>err</ml>
de la fonction vaut <ml>true</ml>, alors la méthode écrira sur la sortie
d'erreur, sinon la méthode de l'objet retourné écrira sur la sortie
standard:
</p>
<oc-eval>
let mk_printer err =
  if err then
    object method print msg = prerr_endline ("erreur: "^msg) end
  else
    object method print = print_endline end
;;
</oc-eval>
<p>Comme attendu, cette fonction prend un booléen et retourne un objet.</p>
<p>Si par mégarde les deux objets n'ont pas un type compatible, le compilateur
le signale, ici en indiquant que les types des méthodes <ml>print</ml>
ne sont pas compatibles:
</p>
<oc-eval error-exc="false">let mk_printer err =
  if err then
    object method print msg = prerr_endline ("erreur: "^msg) end
  else
    object method print = print_int end
;;
</oc-eval>
<p>
Munis de notre fonction <ml>mk_printer</ml>, nous pouvons créer un objet <ml>err_printer</ml>:
</p>
<oc-eval>let err_printer = mk_printer true ;;</oc-eval>
<p>Nous pouvons ensuite définir une fonction prenant en paramètre un objet
dont nous ne donnons pas le type, mais que nous utilisons dans le corps de notre fonction:
</p>
<oc-eval>let hello pr =
  for i = 1 to 3 do pr#print (string_of_int i) done
;;
</oc-eval>
<p>Le type inféré pour le paramètre <ml>pr</ml> est un type objet.
La seule contrainte est qu'il doit posséder une méthode <ml>print : string -> 'a</ml>.
Les <ml>..</ml> dans le type du paramètre signifient que l'objet peut avoir
n'importe quelles autres méthodes de n'importe quels types, ce
qui compte est la présence d'une méthode <ml>print</ml> avec un type
compatible avec <ml>string -> 'a</ml>.
</p>
<p>
Nous pouvons donc logiquement appeler cette fonction en lui passant en argument
notre objet <ml>err_printer</ml> créé plus haut:
</p>
<oc-eval>hello err_printer</oc-eval>
<p>Mais nous pouvons également lui passer un objet anonyme créé juste pour un appel:</p>
<oc-eval>hello (mk_printer false);;
hello (object method foo = 1 method print _ = print_endline "coucou" end);;
</oc-eval>
<p>Bien sûr, si l'objet passé en paramètre ne vérifie pas les contraintes
de type, le compilateur signale une erreur:
</p>
<oc-eval error-exc="false">hello (object method print n = string_of_int n end);;</oc-eval>
<p>
Pour déterminer la compatibilité de deux types objets, la notion de <strong>sous-typage</strong>
est utilisée. On pourra utiliser un objet d'un type t en lieu et place d'un
objet de type t' si t est un sous-type de t'. Un type objet t est sous-type d'un type objet t' si
toutes les méthodes de t' sont présentes dans t. De plus, pour chacune,
son type dans t doit être un sous-type du type de la même la méthode dans t'.
</p>
<p>
Voyons quelques exemples en définissant une fonction dont nous spécifions
le type du paramètre pour qu'il requière une méthode <ml>m : int -> int</ml>
tout en permettant à l'objet passé d'avoir d'autres méthodes (grâce aux <ml>..</ml>):
</p>
<oc-eval><![CDATA[let test (p : < m : int -> int ; .. >) = p#m 1;;]]></oc-eval>
<p>Voyons maintenant la compatibilité avec différents objets:</p>
<oc-eval error-exc="false">
(* objet vide, invalide car la methode m requise est absente *)
test (object end);;
(* objet valide, exactement le meme type *)
test (object method m x = x + 1 end);;
(* objet invalide: m n'a pas le bon type *)
test (object method m x = float x end);;
(* objet valide: 'a -> 'a est un sous-type de int -> int *)
test (object method m x = x end);;
(* objet valide: m du bon type et une methode
   supplementaire ne pose pas de probleme *)
test (object method m x = x + 1 method m2 = "hello" end)
</oc-eval>
<p>Ce dernier cas ne passe que parce que le type exigé pour le paramètre
 de la fonction <ml>test</ml> contient <ml>..</ml>, indiquant que les méthodes
 supplémentaires sont acceptées. Sans ces <ml>..</ml>, le dernier cas ne passe
 pas:
</p>
<oc-eval error-exc="false"><![CDATA[let test2 (p : < m : int -> int >) = p#m 1;;
test2 (object method m x = x + 1 method m2 = "hello" end)
]]></oc-eval>
<p>Un transtypage (<em>cast</em>) est alors nécessaire pour dépouiller l'objet de sa méthode
en trop avant de le passer en paramètre. Le transtypage est réalisé
avec l'opérateur <ml>:&gt;</ml>, qui prend un objet à gauche et un type à droite,
le tout entre parenthèses:
</p>
<oc-eval><![CDATA[let o = object method m x = x + 1 method m2 = "hello" end;;
test2 (o :> < m : int -> int >);;
]]></oc-eval>
<p>Evidemment, dépouiller un objet d'un type t vers un type t' si t n'est
pas un sous-type de t' provoque une erreur:
</p>
<oc-eval error-exc="false"><![CDATA[
let o = object method m = string_of_int end;;
(o :> < m : int -> int >);;
]]></oc-eval>
<p>
On constate que le <strong>système de types d'OCaml ne confond pas sous-typage et héritage</strong>,
puisqu'il n'est pas nécessaire à deux objets d'hériter d'un ancètre commun ou de déclarer
une interface pour pouvoir être utilisés l'un à la place de l'autre lorsque le contexte
le permet. C'est la différence entre
<ext-a href="https://fr.wikipedia.org/wiki/Syst%C3%A8me_structural_de_types">typage structurel</ext-a>
(comme ici) et
<ext-a href="https://fr.wikipedia.org/wiki/Syst%C3%A8me_nominatif_de_types">typage nominal</ext-a>.
</p>


<subsection id="funobjects" title="Objets fonctionnels">
<p>
On appelle <em>objets fonctionnels</em> les objets qui, plutôt que mettre
à jour un état interne lors de l'appel d'une méthode, renvoient une copie
d'eux-mêmes avec éventuellement des modifications des valeurs des attributs
de l'objet original.
</p>
<p id="selfcopy">
La syntaxe pour construire une copie de l'objet en cours en en changeant
certains attributs est la suivante:
</p>
<centerstx>{&lt; <stxid>attribut1</stxid> = <stxid>expr1</stxid> ; <stxid>attribut2</stxid> = <stxid>expr2</stxid> ; ... &gt;} </centerstx>
<p>
Par exemple, nous pourrions faire un objet représentant une liste de la
façon suivante:
</p>
<oc-eval id="exampleobjectlist"><![CDATA[let l =
  object
    val value = []
    method value = value
    method cons h = {< value = h :: value >}
    method hd = List.hd value
    method tl = List.tl value
    method map f = {< value = List.map f value >}
  end;;
let l1 = l#cons 1 ;;
let l2  = ((l1#cons 2)#cons 3)#cons 4 ;;
let l3 = l2#map (fun x -> x + 1);;
l3#value;;
]]></oc-eval>
</subsection>

</section>

<section id="classes" title="Classes">
<p>
Nous avons pour l'instant créé des objets sans passer par la définition
de classes. Nous avons également vu qu'il était possible de définir des
fonctions retournant des objets créés à partir de paramètres.
</p>
<p>
L'utilisation d'objets créés de cette façon, si elle est pratique dans
certains cas, est déconseillée à grande échelle, car elle nuit à
la lisibilité et la maintenabilité du logiciel. Etre capable de nommer
et catégoriser les objets et les concepts est important pour les comprendre
et les manipuler<note>"Mal nommer les classes, c'est ajouter de la misère au logiciel",
disait (presque) Camus.</note>.
</p>
<subsection id="classdecl" title="Déclaration">
<p>
La déclaration d'une classe prend la forme suivante:
</p>
<centerstx>class <stxid>identifiant</stxid> [<stxid>paramètres</stxid>] = object <stxid>champs</stxid> end</centerstx>
<p>
L'<stxid>identifiant</stxid> se trouve dans le même espace de nom que les types,
car la définition d'une classe introduit un nouveau type du même nom.
</p>
</subsection>

<subsection id="classparams" title="Paramètres de classes">
<p>
Voyons quelques exemples de déclarations. Tout d'abord une classe sans paramètre
</p>
<oc-eval>
class c1 = object method hello = print_endline "bonjour le monde!" end ;;
</oc-eval>
<p>Ensuite, déclarons une classe <ml>c2</ml> avec deux paramètres, <ml>x</ml>
et <ml>y</ml>, utilisés pour initialiser deux attributs modifiables de mêmes noms.
Nous déclarons également deux méthodes <ml>as_string</ml> et <ml>move</ml>, cette
dernière modifiant les valeurs des deux attributs:
</p>
<oc-eval><![CDATA[class c2 x y =
  object
    val mutable x = x
    val mutable y = y
    method as_string = Printf.sprintf "(%d, %d)" x y
    method move new_x new_y = x <- new_x ; y <- new_y
  end
]]></oc-eval>
<p>
Comme pour les <doc href="fonctionnelle#def">définitions de fonctions</doc>,
la syntaxe que nous avons utilisée est un raccourci pour une syntaxe plus explicite
utilisant le mot-clé <ml>fun</ml>. Nous pouvons définir une classe <ml>c3</ml>
identique à <ml>c2</ml> de la façon suivante:
</p>
<oc-eval><![CDATA[class c3 = fun x -> fun y ->
  object
    val mutable x = x
    val mutable y = y
    method as_string = Printf.sprintf "(%d, %d)" x y
    method move new_x new_y = x <- new_x ; y <- new_y
  end
]]></oc-eval>
<p>
Cette syntaxe permet d'introduire des calculs intermédiaires avant ou entre les
paramètres, lors de l'instanciation. Elle rappelle qu'une classe,
en plus d'un type, définit l'équivalent d'une fonction de construction, prenant
des paramètres et retournant un objet.
</p>
</subsection>

<subsection id="instanciation" title="Instanciation">
<p>
L'instanciation d'un objet selon une classe est réalisée avec le mot-clé
<ml>new</ml> suivi du nom de la classe et tout ou partie des paramètres éventuels
que celle-ci accepte:
</p>
<oc-eval><![CDATA[let o1 = new c1 ;;
o1#hello ;;
let objet_c2 = new c2 3 5 ;;
objet_c2#as_string ;;
objet_c2#move 25 73 ;;
objet_c2#as_string ;;
]]></oc-eval>
<p>
Au passage, on constate que le type indiqué n'est plus de la forme
<ml>&lt; .. &gt;</ml>, mais que par concision le nom de la classe est utilisé
(puisque la déclaration d'une classe entraîne la création d'un type du même nom).
</p>
<p>
Puisque <ml>c2</ml> accepte des paramètres, nous pouvons appliquer partiellement
l'instanciation, en ne fournissant qu'une partie des paramètres:
</p>
<oc-eval><![CDATA[
(* application partielle: aucun parametre n'est donne *)
let mk_c2 = new c2 ;;
(* on donne un parametre a la fonction retournee *)
let mk_c2_10 = mk_c2 10 ;;
(* on fournit le dernier parametre a la fonction mk_c2_10
  qui retourne alors un objet de type c2 *)
let o = mk_c2_10 20 ;;
o#as_string ;;
]]></oc-eval>
<p>
Pour bien comprendre ce qui est calculé et à quel moment, définissons
une classe prenant plusieurs paramètres et insérons entre ces deniers
des affichages:
</p>
<oc-eval>class c4 =
  let () = print_endline "this message is printed at the class declaration time" in
  fun x ->
    let () = Printf.printf "got x=%d\n%!" x in
    let z = -x in
    let () = Printf.printf "defined z=%d\n%!" z in
    fun y ->
      let () = Printf.printf "got y=%d\n%!" y in
      object
        initializer
          Printf.printf "initializer: x=%d, y=%d, z=%d\n%!" x y z
      end;;
</oc-eval>
<p>
Le premier affichage est fait dès la déclaration de la classe, car aucun
paramètre attendu n'empêche son évaluation. Voyons le résultat d'applications
partielles successives:
</p>
<oc-eval>let o = new c4 (* o est maintenant une fonction *) ;;
let o2 = o 1 (* x = 1 et en interne z=-1 *);;
let o3 = o2 10 (* y = 10, tous les parametres sont founis, l'objet est cree *);;
</oc-eval>
<p>
La séquence d'instructions (<ml>;</ml>) est interdite avant la partie <ml>object ... end </ml>,
ce qui nous oblige à utiliser la constrution <ml>let () = ... in</ml> pour réaliser
des effets de bord (affichage).
</p>
<p>
La définition de valeurs entre les paramètres, mais surtout avant le
<ml>object ... end</ml> permet de faire des calculs et opérations
avant la création de l'objet. Les résultats de ces calculs peuvent être
utilisés dans les méthodes et surtout dans les attributs, pour leur fournir
des valeurs d'initialisation. Souvenons-nous que l'initialisation d'un
attribut ne peut utiliser la valeur d'un autre attribut lors de la création
de l'objet.
</p>
</subsection>

<subsection id="constructors" title="Constructeurs">
<p>
Il n'y a pas de notion de constructeur pour les objets en OCaml, ou plutôt
il n'y a qu'un seul constructeur, appelé par <ml>new</ml> suivi du nom de la
classe.
</p>
<p>
Il n'y a pas non plus de de surcharge.
Cependant, les paramètres d'une classe peuvent être utilisés pour l'instancier
avec des valeurs différentes selon le contexte.
Les <doc href="stdlib#exooptparams">paramètres optionnels</doc>
sont une façon aisée d'obtenir différentes façons d'instancier une classe:
</p>
<oc-eval session="trash">class point ?(x=0) ?(y=0) () =
  object
    val x = x
    val y = y
    method as_string = Printf.sprintf "(%d, %d)" x y
  end;;
let origin = new point () ;;
let p = new point ~x: 1 ();;
let q = new point ~x: 2 ~y: 3 () ;;
List.iter (fun o -> print_endline o#as_string) [ origin ; p ; q ];;
</oc-eval>
<p>
Le paramètre <ml>()</ml> est nécessaire dans la déclaration pour que le compilateur
puisse distinguer si <ml>new point</ml> attend ou non des paramètres optionnels.
L'application est totale lorsque le paramètre non optionnel est explicitement donné.
</p>
</subsection>

<subsection id="destructors" title="Destructeurs">
<p>
Il n'y a pas de libération explicite des objets. Ces derniers, comme les
autres valeurs OCaml, sont désalloués lorsqu'ils deviennent inaccessibles.
</p>
<p>
Il est cependant possible, comme pour d'autres valeurs OCaml, d'associer
une fonction à appeler lors de la désallocation de l'objet, grâce
à la fonction <ml>finalise</ml> du module <moduledoc name="Gc"/>. Dans l'exemple
ci-dessous, nous créons des objets avec un nom et qui affichent une chaîne
lorsqu'ils sont sur le point d'être libérés:
</p>
<oc-eval session="trash">
class myclass s =
  object(self)
    val name = s
    method on_destroy = print_endline (name^" is being destroyed!")
    initializer
      Gc.finalise (fun o -> o#on_destroy) self
  end
;;
for i = 1 to 3 do
    ignore (new myclass ("object "^string_of_int i))
  done;;
</oc-eval>
<!-- en fait il faut faire deux fois Gc.major() dans notre environnement -->
<ocaml-eval session="trash" show-code="false">Gc.major ();;</ocaml-eval>
<p>Nous forçons la récupération des miettes par le <em>garbage collector</em>:</p>
<oc-eval session="trash">Gc.major ();;</oc-eval>
</subsection>


<subsection id="classexercises" title="Exercices">
<exercice id="exostack" title="Implémentation d'une pile d'entiers">
<p>
Implémenter une pile d'entiers à l'aide d'une classe. L'état de la pile
sera naturellement dans un attribut (variable d'instance) modifiable.
Les méthodes permettront d'effectuer les actions suivantes:
<ml>push : int -> unit</ml>,
<ml>pop : int option</ml>,
<ml>peek : int option</ml> (retourne l'élément en haut de la pile mais sans la modifier),
<ml>is_empty : bool</ml>.
</p>
<p>
Nous implémentons une pile d'entiers car nous verrons le polymorphisme
<doc href="#clpolym">plus loin</doc>.
</p>
<solution>
<oc-eval><![CDATA[
(* implementation d'une pile d'entiers avec une liste *)
class stack =
  object
    val mutable elements = ([] : int list)
    method push n = elements <- n :: elements
    method pop =
      match elements with
        [] -> None
      | h :: q -> elements <- q ; Some h
    method peek =
      match elements with [] -> None | h :: _ -> Some h
    method is_empty = elements = []
  end;;
]]></oc-eval>
</solution>
<oc-eval>
let stack = new stack ;;
List.iter stack#push [ 1 ; 2 ; 3 ; 4 ; 5 ];;
let rec print stack =
  match stack#pop with
    None -> assert stack#is_empty
  | Some n -> print_endline (string_of_int n); print stack
;;
print stack;;
</oc-eval>
</exercice>

<exercice id="exostackfun" title="Implémentation d'une pile avec une classe fonctionnelle">
<p>Implémenter une pile d'entiers à l'aide d'une classe "fonctionnelle" <ml>fun_stack</ml>,
i.e. dont les méthodes retournent un nouvel objet au lieu de faire
un effet de bord sur l'état interne. La classe aura les méthodes suivantes:
<ml>push : int -> fun_stack</ml>,
<ml>pop : (int * fun_stack) option</ml>,
<ml>peek : int option</ml> (retourne l'élément en haut de la pile mais sans la modifier),
<ml>is_empty : bool</ml>.
</p>
<solution>
<oc-eval><![CDATA[class fun_stack =
  object
    val elements = ([] : int list)
    method push n = {< elements = n :: elements >}
    method pop =
      match elements with
        [] -> None
      | h :: q -> Some (h, {< elements = q >})
    method peek =
      match elements with [] -> None | h :: _ -> Some h
    method is_empty = elements = []
  end;;
]]></oc-eval>
</solution>
<oc-eval>
let stack = new fun_stack ;;
let stack =
  List.fold_left (fun st n -> st#push n) stack [ 1 ; 2 ; 3 ; 4 ; 5 ];;
let rec print stack =
  match stack#pop with
    None -> assert stack#is_empty
  | Some (n, stack) -> print_endline (string_of_int n); print stack
;;
print stack;;
</oc-eval>
</exercice>
</subsection>

<subsection id="classrec" title="Classes mutuellement récursives">
<p>
Il peut parfois être utile de définir des classes se connaissant les unes
les autres, de façon à ce que chacune puisse instancier les autres.
De la même façon que pour les types, il suffit d'utiliser le mot-clé <ml>and</ml>
de la façon suivante:
</p>
<oc-eval>class class1 x =
    object
      val x = x
      method make_c2 = new class2 x 10
    end
  and class2 x y =
    object
      method as_string = Printf.sprintf "(%d,%d)" x y
      method c1 = new class1 x
    end;;
let objet_c1 = new class1 42 ;;
let objet_c2 = objet_c1#make_c2;;
objet_c2#as_string ;;
</oc-eval>
</subsection>

</section>




<section id="inheriting" title="Héritage">
<p>
Une classe ou un objet peuvent hériter d'une classe
existante. Par contre, il est impossible d'hériter d'un objet.
</p>
<subsection id="inheritmeca" title="Mécanisme d'héritage">
<p>
L'héritage est introduit par le mot-clé <ml>inherit</ml> suivi d'un
nom de classe et de ses éventuels paramètres. L'exemple suivant,
d'un classicisme éhonté, définit une classe <ml>point</ml> et,
héritant de cette dernière, une classe <ml>colored_point</ml>.
Nous ajoutons des affichages dans les blocs <ml>initializer</ml>
afin de montrer l'ordre d'initialisation:
</p>
<oc-eval><![CDATA[class point ?(x=0) ?(y=0) () =
  object
    val mutable x = x
    val mutable y = y
    method x = x
    method y = y
    method move new_x new_y = x <- new_x ; y <- new_y
    method as_string = Printf.sprintf "(%d,%d)" x y
    initializer
      Printf.printf "init point with x=%d, y=%d\n%!" x y
  end;;
class colored_point ?(color=0x000) ?x ?y () =
  object(self)
    inherit point ?x ?y () as super
    val mutable color = color
    method color = color
    method set_color c = color <- c
    method as_string = Printf.sprintf "%s[%x]" super#as_string color
    method as_point = (self :> point)
    initializer
      Printf.printf "init colored_point with x=%d, y=%d, color=%x\n%!" x y color
  end;;
let origin = new point () ;;
let colored_origin = new colored_point ~color: 0xa00 () ;;
origin#as_string ;;
colored_origin#as_string ;;
]]></oc-eval>
<p>
Le champ <ml>inherit point ?x ?y () as super</ml> indique que la classe
<ml>colored_point</ml> hérite de la classe <ml>point</ml> et que, lors
de la création de l'objet de la classe <ml>colored_point</ml>, la partie
correspondant à l'héritage de <ml>point</ml> sera construite avec les
paramètres indiqués (<ml>?x ?y ()</ml>).
</p>
<p>
De plus, le mot-clé <ml>as</ml> permet de donner un identifiant pour faire
appel aux méthodes de la classe héritée. Nous nous en servons dans la redéfinition
de la méthode <ml>as_string</ml>, en faisant appel à <ml>super#as_string</ml>.
</p>
<p>La classe <ml>colored_point</ml> contient également une méthode <ml>as_point</ml>
renvoyant l'objet dépouillé pour être du type <ml>point</ml> (utilisation de l'opérateur
de transtypage <ml>:&gt;</ml>). Attention cependant, les méthodes qu'il porte
restent celles de la classe <ml>colored_point</ml>:
</p>
<oc-eval>colored_origin#as_point#as_string ;;</oc-eval>
<warning id="warnoverride" title="Redéfinition d'attributs et de méthodes">
<p>
Par défaut, le compilateur n'émet pas d'avertissement lorsqu'une méthode
héritée est masquée par la redéfinition de la méthode dans la classe héritante.
</p>
<p>Un avertissement (le numéro 7) peut être activé pour éviter de redéfinir
par mégarde une méthode. Idem pour un attribut (numéro 13).
Pour éviter l'avertissement quand il est activé, on ajoute un <ml>!</ml>
à <ml>val</ml> ou <ml>method</ml>, signifiant que la redéfinition est volontaire:
</p>
<oc-eval>
#warnings "+7+13";;
class foo =
  object
    inherit point ~x: 0 ~y: 0 ()
    val! mutable x = 0
    val mutable y = 0
    method x = x
    method! as_string = "foo"
  end;;
</oc-eval>
</warning>
<p>
La redéfinition d'attributs ou de méthodes doit respecter la définition
de la classe héritée: même type et, pour les attributs, même possibilité de modification
ou non.
</p>
</subsection>
<subsection id="inheritmulti" title="Héritage multiple">
<p>
L'héritage multiple est possible, en utilisant plusieurs fois le mot-clé <ml>inherit</ml>.
Les attributs et méthodes sont hérités dans l'ordre d'apparition des
<ml>inherit</ml>, une méthode héritée pouvant être re-définie par une autre méthode
héritée plus loin. Idem pour les attributs.
</p>
<p>
Là encore, on utilisera le <ml>!</ml> après le mot-clé <ml>inherit</ml> pour indiquer
que la redéfinition de méthodes et attributs hérités d'une première classe, par ceux
d'une seconde classe héritée, est volontaire:
</p>
<oc-eval>class t1 = object val value = 1 method p = "class t1" end;;
class t2 = object method p = "class t2" end;;
class t3 = object val value = 42 end;;
class t4 = object
  inherit t1
  inherit! t2 (* noter le ! *)
  inherit t3 (* l'absence de ! provoque un warning *)
  method value = value
 end;;
print_endline (new t4)#p ;;
(new t4)#value ;;
</oc-eval>
</subsection>
</section>

<section id="virtual" title="Classes et méthodes virtuelles">
<p>
Il est bien sûr possible de définir des méthodes virtuelles, c'est-à-dire
des méthodes dont on donne déjà le type, mais dont l'implémentation
devra être fournie plus tard, dans une classe héritante. On déclare
des méthodes virtuelles à l'aide du mot-clé <ml>virtual</ml>, et au lieu
de donner l'expression du corps de la méthode, on indique son type,
comme dans une <doc href="#classintf">interface de classe</doc>.
</p>
<p>
A partir du moment où au moins une méthode requise n'est pas définie
(donc au moins une méthode est encore virtuelle), la classe doit être
déclarée comme virtuelle, toujours à l'aide du mot-clé <ml>virtual</ml>.
</p>
<p>
Définissons une classe virtuelle <ml>stringable</ml> contenant une
méthode virtuelle <ml>as_string</ml>, ainsi qu'une méthode concrète
(le contraire de virtuelle) <ml>print</ml>, qui fait appel à la méthode
virtuelle pour afficher la représentation en chaîne sur la sortie standard:
</p>
<oc-eval>class virtual stringable =
  object(self)
    method print = print_endline (self#as_string)
    method virtual as_string : string
  end;;
</oc-eval>
<p>
Il est impossible pour l'instant d'instancier cette classe, puisqu'elle
est virtuelle:
</p>
<oc-eval error-exc="false">
let o = new stringable ;;
</oc-eval>
<p>
Nous pouvons définir une nouvelle classe, héritant de <ml>stringable</ml>
et implémentant la méthode manquante:
</p>
<oc-eval>class my_c x =
  object
    inherit stringable
    method as_string = string_of_int x
  end;;
</oc-eval>
<p>
Il devient possible d'instancier cette classe:
</p>
<oc-eval>let o = new my_c 42 ;;
o#print ;;
</oc-eval>
<p>
Il n'est évidemment pas possible de créer un objet avec une méthode
virtuelle:
</p>
<oc-eval error-exc="false">
let o = object method virtual print : unit end ;;
</oc-eval>
</section>

<section id="cltypes" title="Types, polymorphismes">
<subsection id="classintf" title="Interfaces de classes">
<p>
Les interfaces de classes sont l'équivalent des signatures pour les modules; on
parle en anglais de <em>class types</em>, les types de classes, comme on parle
de types de modules.
</p>
<p>
Une interface de classe liste des attributs et méthodes avec leur type,
mais pas leur valeur:
</p>
<oc-eval>class type ctype =
  object
    val mutable foo : int
    method as_string : string
  end;;
</oc-eval>
<p>
Nous pouvons nous servir d'une telle interface pour restreindre le type
d'une classe:
</p>
<oc-eval>class ma_classe : ctype =
  object
    val mutable foo = 42
    val gee = "hello"
    method as_string = string_of_int foo
  end;;
let o = new ma_classe;;
</oc-eval>
<p>
Si le type de la classe n'est pas un sous-type de l'interface, le compilateur
signale une erreur:
</p>
<oc-eval error-exc="false">class ma_classe : ctype =
  object
    val mutable foo = "hello"
    val gee = "world"
    method as_string = foo
  end;;
</oc-eval>

<p>
Lorsqu'on restreint le type d'un objet, seules les méthodes sont contraintes,
car les attributs de l'objet n'apparaissent pas dans son type:
</p>
<oc-eval error-exc="false">(* as_string est de type 'a, sous-type de string, donc ok *)
let o = object val mutable foo = 42 method as_string = assert false end;;
let (o2 : ctype) = o;;
(* l'absence de l'attribut foo n'est pas un probleme *)
let o3 = object method as_string = "hello" end;;
let (o4 : ctype) = o3;;
(* ici, la methode as_string n'est pas du bon type *)
let o5 = object method as_string = 42 end;;
let (o6 : ctype) = o5;;
</oc-eval>

<warning id="hidingmethods" title="Masquage des méthodes publiques ou virtuelles">
<p>
Il n'est pas possible de masquer, à l'aide d'une contrainte de type, les méthodes
publiques et les <doc href="#virtual">méthodes virtuelles</doc>:
</p>

<oc-eval error-exc="false">class ma_classe : ctype =
  object
    val mutable foo = 42
    method as_string = string_of_int foo
    method hello = print_endline "hello world!"
  end;;
</oc-eval>
</warning>
</subsection>

<subsection id="clpolym" title="Polymorphisme de classe">
<p>
<doc href="fonctionnelle#Lesparamtresdestypespara">Comme les types</doc>,
les définitions de classes peuvent être paramétrées par des variables de type:
</p>
<centerstx>class ['a] <stxid>identifiant</stxid> ... = object <stxid>champs</stxid> end
class ['a, 'b, ...] <stxid>identifiant</stxid> ... = object <stxid>champs</stxid> end</centerstx>
<p>
Le type créé lorsqu'une classe est déclarée est lui aussi paramétré par les mêmes
variables de type.
</p>
<p>
Lorsqu'une classe est paramétrée de cette sorte, il devient possible d'utiliser les
variables de type dans les annotations de type dans la définition de la classe.
En reprenant <doc href="#exampleobjectlist">notre exemple d'interface objet pour une liste</doc>,
nous pouvons maintenant définir une classe représentant une liste d'éléments d'un
type quelconque:
</p>
<oc-eval><![CDATA[class ['a] clist =
  object
    val value = ([] : 'a list)
    method value = value
    method cons h = {< value = h :: value >}
    method hd = List.hd value
    method tl = List.tl value
    method map f = {< value = List.map f value >}
  end;;
]]></oc-eval>
<p>
On remarque que le type indiqué pour la classe contient une annotation
de type <ml>object('b)...</ml> et que ce <ml>'b</ml> est utilisé dans le
type des méthodes qui retournent une copie de l'objet.
</p>
<p>Instancions maintenant cette classe:</p>
<oc-eval>let l = new clist ;;</oc-eval>
<p>On constate que l'objet <ml>l</ml> a pour type <ml>_'a clist</ml>, ce qui signifie
qu'il contiendra des éléments d'un type non encore connu, mais que dès que ce type
sera connu, il ne sera plus possible d'ajouter des éléments d'un autre type
à notre liste:
</p>
<oc-eval error-exc="false">
let l1 = l#cons 1 ;;
let l2  = ((l1#cons 2)#cons 3)#cons 4 ;;
let l3 = l2#map (fun x -> x + 1);;
l3#value;;
let l4 = l#cons "hello" ;;
</oc-eval>
<p>
Il est possible de définir une classe paramétrée par un ou plusieurs types,
tout en posant des contraintes sur ces types. Ainsi, nous pouvons paramétrer
notre classe par un type <ml>'a</ml>, et imposer que ce type soit
un sous-type de <ml>point</ml>, grâce au mot-clé <ml>constraint</ml>.
La notation <ml>constraint 'a = #point</ml> dénote cette contrainte, le
<ml>#</ml> signifiant "tout type sous-type de <ml>point</ml>, avec
éventuellement des méthodes supplémentaires":
</p>
<oc-eval><![CDATA[class ['a] circle c radius =
  object
    constraint 'a = #point
    val center = (c : 'a)
    method radius = (radius : float)
    method as_string = Printf.sprintf "%s--%.2f" center#as_string radius
  end;;
let circ = new circle origin 2.0;;
circ#as_string;;
let circ2 = new circle colored_origin 3.0 ;;
circ2#as_string;;
]]></oc-eval>
<p>Si la contrainte de type n'est pas respectée lorsqu'on passe le
centre à la création de l'objet <ml>circle</ml>, une erreur est signalée:
</p>
<oc-eval error-exc="false">
let p = object method x = 1  method y = 2  method as_string = "(1,2)" end;;
let circ = new circle p 2.0;;
</oc-eval>
<p>
Lorsqu'on hérite d'une classe paramétrée par des variables de type,
il faut indiquer une valeur pour ces variables de type à la suite du
mot-clé <ml>inherit</ml>:
</p>
<oc-eval>class string_list =
  object
    inherit [string] clist
  end;;
</oc-eval>
<p>On peut bien sûr utiliser des variables de type de la classe en
cours de définition:
</p>
<oc-eval>class ['a] clist2 =
  object
    inherit ['a] clist
    method length = List.length value
  end;;
</oc-eval>
<p>
Avec les classes paramétrées par des variables de type, on obtient
des constructeurs polymorphes d'objets, mais pas des objets polymorphes,
c'est-à-dire que les types des objets instanciés (notamment les types des méthodes)
ne contiennent pas de variables de type libres. Nous allons maintenant voir
comment définir des objets dont certaines méthodes sont polymorphes.
</p>
</subsection>

<subsection id="polymeths" title="Méthodes polymorphes">
<p>
Lorsqu'on définit un objet, le type de ses méthodes est le plus général
possible, tout comme lors de la définition d'une fonction:
</p>
<oc-eval>
let f x y = [ x ; y ];;
let o = object method f x y = [x ; y] end;;
o#f 1 2;;
o#f "hello" "world";;
</oc-eval>
<p>
A contrario, comme la définition d'une classe donne lieu à la création
d'un type, il n'est pas possible de laisser des variables de type libres
dans le type de la classe, de la même façon qu'il ne peut y avoir de
variable de type libre dans la définition d'un type:
</p>
<oc-eval error-exc="false">
type t = 'a -> 'a -> 'a list;;
class c = object method f x y = [x ; y] end;;
</oc-eval>
<p>
Introduire des paramètres de types ne suffit pas à rendre une
méthode polymorphe, car son type sera instancié lors de l'instanciation
de la classe. Avec un paramètre de type à notre classe, on a donc un
constructeur polymorphe d'objets, mais pas des objets avec des méthodes
polymorphes:
</p>
<oc-eval error-exc="false">class ['a] c = object method f (x:'a) (y:'a) = [x ; y] end;;
let o = new c;;
o#f 1 2 ;;
(* le type de o est completement connu, il n'est plus polymorphe *)
o#f "hello" "world";;
</oc-eval>
<p>
Pour définir une méthode polymorphe, il faut explicitement indiquer sur quelles
variables de son type porte le polymorphisme, en introduisant des quantificateurs
dans son type, suivis d'un <ml>.</ml>. Reprenons la définition de notre classe,
qui n'a plus besoin en l'occurrence d'être paramétrée par un type, et utilisons
un quantificateur en explicitant le type de la méthode <ml>f</ml>:
</p>
<oc-eval>class c = object
    method f : 'a. 'a -> 'a -> 'a list = fun x y -> [x ; y]
  end;;
(* le type de la classe montre maitenant bien une methode polymorphe, avec des
  variables de type libres *)
let o = new c;;
o#f 1 2 ;;
o#f "hello" "world";;
</oc-eval>
<p>
On peut évidemment quantifier sur plusieurs variables, et mixer paramètres
de types de la classe et méthodes polymorphes:
</p>
<oc-eval>class ['a] triple (x:'a) =
  object
    method mk :'b 'c . 'b -> 'c -> 'a * 'b * 'c  = fun y z -> (x, y, z)
  end;;
let mk1 = new triple 1 ;;
mk1#mk "hello" 42 ;;
mk1#mk 42 "hello";;
</oc-eval>

<exercice id="clistmap" title="Ajout d'une méthode polymorphe">
<p>
Modifier la définition de la classe <ml>clist</ml> pour qu'elle
prenne en paramètre la valeur initiale de la liste et
lui ajouter une méthode <ml>fold_left : ('b -> 'a -> 'b) -> 'b -> 'b</ml>,
utilisant <ml>List.fold_left</ml>.
</p>
<solution>
<oc-eval><![CDATA[
class ['a] clist (init : 'a list)=
  object
    val value = init
    method value = value
    method cons h = {< value = h :: value >}
    method hd = List.hd value
    method tl = List.tl value
    method fold_left : 'b. ('b -> 'a -> 'b) -> 'b -> 'b =
      fun f acc -> List.fold_left f acc value
  end;;
]]></oc-eval>
</solution>
<oc-eval>let ma_liste = new clist [1 ; 2 ; 3 ; 4];;
let sum = ma_liste#fold_left (+) 0;;
let concat = ma_liste#fold_left (fun s x -> s^(string_of_int x)) "";;
</oc-eval>
</exercice>
</subsection>
</section>

<section id="cloningcomp" title="Copie d'objets, comparaison">
<subsection id="cloning" title="Copie">
<p>
Le module <moduledoc name="Oo"/> contient des fonctions relatives aux objets.
La fonction <ml>Oo.copy</ml> copie un objet en copiant ses attributs et méthodes.
Comme son type l'indique, elle prend n'importe quel objet et retourne un objet
du même type (une copie, en l'occurrence):
</p>
<oc-eval>Oo.copy;;</oc-eval>
<p>
Pour les attributs, il s'agit d'une copie "peu profonde" (<em>shallow copy</em>,
tout comme <ml>Array.copy</ml>): Les valeurs des attributs sont partagées, et
la mise à jour d'un attribut dans un objet ne modifie pas l'attribut dans l'objet
copié. Par contre, la copie ne descend pas dans les références, donc si un attribut
contient une référence, modifier la valeur référencée par l'attribut dans un
objet revient à modifier la valeur référencée dans l'objet copié.
</p>
<p>
<oc-eval><![CDATA[
let o = object
    val mutable x = 0
    val y = ref 0
    method set_x x2 = x <- x2
    method x = x
    method set_y y2 = y := y2
    method y = !y
  end;;
let o2 = Oo.copy o;;
o#set_x 42 ; o#set_y 1984 ;;
(* x dans o2 n'a pas ete modifie *)
o2#x ;;
(* la valeur pointee par y a change dans les deux objets, mais
  pas la reference *)
o2#y ;;
]]></oc-eval>
</p>
<p>
Pour copier un objet depuis l'intérieur de lui-même, nous avons vu
l'utilisation de la construction <doc href="#selfcopy"><ml>{&lt; ... &gt;}</ml></doc>.
Si aucun attribut n'est spécifié dans cette construction, cela revient à faire
une copie de l'objet. Cela signifie que les deux méthodes
<ml>copy1</ml> et <ml>copy2</ml> dans le code suivant sont équivalentes:
</p>
<oc-eval><![CDATA[object(self) method copy1 = {< >}  method copy2 = Oo.copy self end;;]]></oc-eval>
</subsection>
<subsection id="comparison" title="Comparaison">
<p>
Il est possible d'utiliser les fonctions de comparaison génériques <ml>Pervasives.compare</ml>,
<ml>(=)</ml>, <ml>(&lt;)</ml>, <ml>(&lt;=)</ml>, ...,
pour comparer deux objets. Le résultat ne sera cependant pas celui espéré:
</p>
<oc-eval><![CDATA[let o = object val x = 42 end;;
let o2 = object val x = 42 end;;
let o3 = Oo.copy o2 ;;
o = o2 ;;
o2 = o3 ;;
o = o;;
]]></oc-eval>
<p>En effet, deux objets sont égaux s'ils ont la même adresse physique.</p>
<p>
La relation d'ordre générique est basée sur l'identifiant interne de l'objet
(son numéro dans l'ordre de création des objets),
que l'on obtient grâce à la fonction <ext-a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Oo.html#VALid"><ml>Oo.id</ml></ext-a>:
</p>
<oc-eval>let obj1 = object val y = "hello" end;;
let obj2 = object val y = "abc" end;;
obj1 &lt; obj2;;
Oo.id obj1 ;;
Oo.id obj2 ;;
</oc-eval>
<p>
Il convient donc d'implémenter la fonction de comparaison adaptée, en accédant
aux attributs des objets à comparer. On implémente parfois ces comparaisons
dans des méthodes binaires.
</p>
<p>
Par ailleurs, les identifiants des objets ne sont pas conservés lors
de la sérialisation; de nouveaux identifiants sont regénérés lors de
la re-création des objets. Il conviendra donc de s'appuyer sur ces
identifiants ave parcimonie.
</p>
</subsection>
</section>

<section id="binarymethods" title="Méthodes binaires">
<p>
Une méthode binaire est une méthode prenant en paramètre un objet du
même type que celui auquel elle est appliquée.
</p>
<p>
Dans l'exemple ci-dessous, nous définisson une classe <ml>integer</ml>
dont deux méthodes sont binaires, en indiquant que leur paramètre est
un objet du même type que la classe:
</p>
<oc-eval><![CDATA[class integer (n : int) =
  object (_ : 'a)
     val value = n
     method value = n
     method add (o : 'a) = {< value = n + o#value >}
     method compare (o : 'a) = n - o#value
  end;;
]]></oc-eval>
<p>
Nous pouvons ensuite instancier cette classe et utiliser la méthode binaire
<ml>add</ml> qui renvoie ici un nouvel objet <ml>integer</ml>:
</p>
<oc-eval>
let n1 = new integer 1 ;;
let n2 = new integer 2 ;;
let n3 = n1#add n2;;
n3#value ;;
</oc-eval>
<p>
Définissons maintenant une classe <ml>integer2</ml> héritant de notre classe
<ml>integer</ml>. Nous lui ajoutons une méthode <ml>add_int</ml>.
Ce faisant, deux objets instanciés par ces deux classes n'ont pas le
même type, on ne peut donc utiliser un objet de type <ml>integer</ml>
en paramètre de la méthode <ml>add</ml> d'un objet de type <ml>integer2</ml>.
</p>
<oc-eval error-exc="false"><![CDATA[class integer2 n =
  object
    inherit integer n
    method add_int i = {< value = n + i >}
  end;;
let c1 = new integer2 1 ;;
c1#add n2 ;;
]]></oc-eval>
<p>Par contre, nous pouvons passer en paramètre un objet de type
<ml>integer2</ml>:
</p>
<oc-eval>
let c2 = new integer2 2 ;;
c2#add c2 ;;
</oc-eval>
</section>

<section id="conclusion" title="Conclusion">
<p>
Comme nous l'avons vu, la programmation orientée objets en OCaml
</p>
<ul>
<li>est <strong>très souple</strong>, grâce à la possibilité de créer des objets sans
classe et au fait que la relation de sous-typage ne dépend pas de l'héritage,</li>
<li>est <strong>sûre</strong>, car la partie objets est totalement intégrée au système
de type, sans pour autant être lourde grâce à l'inférence de types,</li>
<li>offre toujours une <strong>grande généricité</strong>, grâce aux différents
polymorphismes.</li>
</ul>
</section>
</contents>
</module>
