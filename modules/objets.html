<module title="Programmation Orientée Objets"
with-contents="true"
ocaml-session="objets"
draft="true"
>
<contents>
<section counter="false" id="preambule" title="Préambule">
<p>Ce document n'est <strong>pas</strong> une introduction au
paradigme de la programmation objets, mais présente la
programmation objets <strong>en OCaml</strong>. On suppose
donc que les notions de classes, objets, méthodes, héritage, etc.,
sont déjà connues.
</p>
</section>

<section id="introduction" title="Introduction">
<p>
OCaml s'appelait auparavant <i>Objective</i>-Caml, indiquant ainsi
qu'il comporte la possibilité de programmation objets.
</p>
<p>
Cela signifie que le système de types permet de définir des types
pour les objets. La définition d'une classe entraîne la création
d'un type (de même nom). L'instanciation d'une classe crée donc
une valeur du type de la classe.
</p>
<p>
Comme les autres types, les types de classes peuvent également
être paramétrés (cf. <doc href="fonctionnelle#decltypes"/>).
</p>
<p>
La notion de type pour les classes s'accompagne de la notion
de sous-typage, ou <em>polymorphisme d'inclusion</em>. Ainsi, un objet
A dont le type est un sous-type
d'un autre objet B pourra être utilisé en lieu et place de B.
Une relation de sous-typage est typiquement engendrée par
héritage, comme dans d'autres langages, mais nous verrons
qu'elle est indépendante et que c'est un aspect intéressant
du langage.
</p>
<p>
L'une des limites d'OCaml est l'impossibilité de surcharger les
méthodes d'une classe, pour la même raison qu'il est impossible
de surcharger les opérateurs: il ne serait alors plus possible
d'inférer automatiquement le type des expressions.
</p>
</section>

<section id="objects" title="Objets">
<p>
Nous commençons par voir comment créer et manipuler des objets,
sans créer de classe. Par la suite, nous verrons comment créer
des classes et les instancier.
</p>
<subsection id="creatingobjects" title="Création d'objets">
<p>
La création d'un objet se fait avec la syntaxe suivante:
</p>
<centerstx>object <stxid>champs</stxid> end</centerstx>
<p>
Les <stxid>champs</stxid> de la définition permettent de définir
pour l'objet ses héritages, attributs (ou variables d'instance),
méthodes, contraintes de types,
ainsi qu'un éventuel traitement à effectuer à l'initialisation.
</p>
<p>Le code suivant déclare un objet "vide", sans attribut ni rien:</p>
<oc-eval>object end ;;</oc-eval>

<p>Créons maintenant un objet un peu plus utile avec une méthode <ml>add : int -> int</ml>,
et un attribut non modifiable <ml>foo : int</ml> initialisé à <ml>1</ml>:
</p>
<oc-eval>object
    val foo = 1
    method add x = x + foo
  end;;
</oc-eval>
<p>
Le toplevel nous indique que la valeur a un type objet (<ml>&lt;obj&gt;</ml>)
et liste les méthodes visibles entre <ml>&lt;</ml> et <ml>&gt;</ml>,
en l'occurrence la méthode <ml>add : int -> int</ml>. Lorsqu'elle sera
appelée avec un paramètre <ml>x</ml> entier, la méthode <ml>add</ml> retournera
la valeur du corps de la méthode, ici l'expression <ml>x + foo</ml>
(<doc href="fonctionnelle#Lavaleurderetourdunefonc">comme pour les fonctions</doc>).
</p>

<p>Lors de la création de l'objet, les expressions d'initialisation
des attributs ne peuvent faire appel aux valeurs d'autres attributs
de l'objet:
</p>
<oc-eval error-exc="false">
object
    val x = 1
    val y = x + 1
  end
</oc-eval>
<p>
Le code à l'intérieur d'un objet peut accéder aux attributs en utilisant
simplement leur identifiant. Ici nous définissons un attribut <ml>foo</ml>
et une méthode <ml>foo</ml>. Les attributs et méthodes sont dans deux espaces
de noms différents. La méthode <ml>foo</ml> utilise l'attribut <ml>foo</ml>:
</p>
<oc-eval>object
    val foo = 1
    method foo = foo
  end
</oc-eval>
<p>
Pour appeler une méthode de l'objet depuis l'intérieur de l'objet,
il faut donner un nom à l'objet dans lequel on est; cela se fait en indiquant un
identifiant entre parenthèses après le mot-clé <ml>object</ml>, ici <ml>self</ml>.
On peut alors appeler la méthode sur l'objet <ml>self</ml>:
</p>
<oc-eval><![CDATA[let o =
  object(self)
    (* Ne faîtes pas ça chez vous :-) *)
    method fact n =
      if n <= 0
        then 0
        else if n = 1
          then 1
          else n * self#fact (n-1)
  end;;
o#fact 5 ;;]]></oc-eval>
</subsection>

<subsection id="letobject" title="Utilisation d'objets">
<p>
L'utilisation d'un objet passe par l'appel de ses méthodes.
L'appel de méthode (aussi appelé <em>envoi de message</em>)
 se fait en utilisant l'opérateur <ml>#</ml> avec
à gauche un objet et à droite le nom de la méthode éventuellement suivi
des arguments:
</p>
<centerstx><stxid>identifiant</stxid> # <stxid>méthode</stxid> [<stxid>arguments</stxid>]</centerstx>
<p>Par exemple, nous créons un objet <ml>x</ml> et appelons la méthode
<ml>as_string</ml> de cet objet:
</p>
<oc-eval>let x = object method as_string = "hello world!" end;;
x#as_string ;;
</oc-eval>
<p>
Contrairement aux valeurs fonctionnelles (ou fonctions), qui doivent avoir
au moins un paramètre pour mériter ce nom et retarder l'évaluation jusqu'au
moment où un argument est donné, les méthodes sans paramètre ne sont évaluées
que lors de leur appel explicite via un objet. En fait, dans le code
généré, ce sont des fonctions qui prennent en premier paramètre l'objet
en question. La méthode <ml>as_string</ml> ci-dessus ne prend pas de paramètre
mais son corps n'est évalué que lorsqu'elle est appelée sur un objet,
c'est-à-dire, dans le code généré, quand un objet lui est passé en paramètre.
Lorsqu'on utilise la notation <ml>object(self) ... end</ml>, on donne justement
un nom à ce paramètre implicite qu'est l'objet, et on peut donc en appeler
des méthodes.
</p>
<warning id="valsnotaccessible" title="Les attributs ne sont pas accessibles à l'extérieur">
<p>
Les attributs d'un objet ne sont pas accessibles depuis l'extérieur de cet objet:
</p>
<oc-eval error-exc="false"> let objet = object val x = 3 end;;
objet#x ;;
objet.x ;;
</oc-eval>
<p>Il est nécessaire de fournir les accesseurs (méthodes d'accès) pour les attributs
auxquels on permet l'accès depuis l'extérieur de l'objet, c'est-à-dire des
méthodes se contentant de retourner le contenu d'un attribut. Par convention,
ces méthodes portent le même nom que l'attribut dont elles renvoient la valeur,
mais ce n'est pas obligatoire:
</p>
<oc-eval error-exc="false"> let objet = object val x = 3 method x = x end;;
objet#x ;;
</oc-eval>
</warning>

</subsection>

<subsection id="initializer" title="Exécution de code à l'initialisation">
<p>
Le mot-clé <ml>initializer</ml> permet de spécifier du code
qui sera exécuté à la création de l'objet.
Ce code est exécuté après initialisation de tous les attributs; il
peut donc accéder aux valeurs des attributs et appeler des méthodes
de l'objet (en donnant un nom à l'objet, ici encore <ml>self</ml>).
</p>
<oc-eval>let o =
  object(self)
    val message = "hello world!"
    method hello = print_endline message
    initializer
      self#hello
  end;;
o#hello;;
</oc-eval>
</subsection>

<subsection id="mutablefields" title="Attributs mutables">
<p>
Par défaut, un attribut n'est pas modifiable. Mais, de la même façon que
pour <doc href="imperative#mutrecords">les types enregistrements</doc>,
le mot-clé <ml>mutable</ml> permet d'avoir des attributs modifiables par
le code à l'intérieur de l'objet. La modification d'un attribut
est réalisée, comme pour les champs d'enregistrements, avec l'opérateur
<ml>&lt;-</ml>:
</p>
<oc-eval><![CDATA[let o =
  object
    val mutable cpt = 0
    method incr = cpt <- cpt + 1
    method print = print_endline (string_of_int cpt)
  end;;
o#incr ;;
o#incr ;;
o#print ;;
]]></oc-eval>
<p>
Le compilateur signale une erreur si on tente de modifier un attribut
non modifiable:
</p>
<oc-eval error-exc="false"><![CDATA[object
  val cpt = 0
  method incr = cpt <- cpt + 1
end;;]]></oc-eval>
</subsection>


<subsection id="privatemethodes" title="Méthodes privées">
<p>
Le mot-clé <ml>private</ml> permet d'indiquer qu'une méthode est privée,
c'est-à-dire qu'elle ne peut être appelée que depuis une autre méthode de
la classe (ou dans la section <ml>initializer</ml>). Le type inféré
pour l'objet ne comporte pas les méthodes privées, qui sont donc bien
inaccessibles depuis l'extérieur de l'objet:
</p>
<oc-eval error-exc="false">let o =
  object(self)
    method private value = 42
    method as_string = string_of_int self#value
  end;;
o#as_string ;;
o#value ;;
</oc-eval>
</subsection>

</section>

<section id="funobject" title="Compatibilité des objets, sous-typage">
<p>
Un objet étant une valeur comme une autre, il peut être passé à ou renvoyé
par une fonction.
</p>
<p>
Le système de types fera les inférences et vérifications nécessaires pour
s'assurer qu'un objet n'est pas passé là où son type ne correspond pas à ce qui
est attendu. De même, une expression ne pourra renvoyer un objet avec un type
ne correspondant pas aux contraintes locales (par exemple deux objets
de types incompabibles en résultat des deux branches d'une conditionnelle).
</p>
<p>Voyons quelques exemples.</p>
<p>Commençons par définir une fonction qui retournera un objet comportant
une unique méthode <ml>print : string -> unit</ml>. Si le paramètre <ml>err</ml>
de la fonction vaut <ml>true</ml>, alors la méthode écrira sur la sortie
d'erreur, sinon la méthode de l'objet retourné écrira sur la sortie
standard:
</p>
<oc-eval>
let mk_printer err =
  if err then
    object method print msg = prerr_endline ("erreur: "^msg) end
  else
    object method print = print_endline end
;;
</oc-eval>
<p>Comme attendu, cette fonction prend un booléen et retourne un objet.</p>
<p>Si par mégarde les deux objets n'ont pas un type compatible, le compilateur
le signale, ici en indiquant que les types des méthodes <ml>print</ml>
ne sont pas compatibles:
</p>
<oc-eval error-exc="false">let mk_printer err =
  if err then
    object method print msg = prerr_endline ("erreur: "^msg) end
  else
    object method print = print_int end
;;
</oc-eval>
<p>
Munis de notre fonction <ml>mk_printer</ml>, nous pouvons créer un objet <ml>err_printer</ml>:
</p>
<oc-eval>let err_printer = mk_printer true ;;</oc-eval>
<p>Nous pouvons ensuite définir une fonction prenant en paramètre un objet
dont nous ne donnons pas le type, mais que nous utilisons dans le corps de notre fonction:
</p>
<oc-eval>let hello pr =
  for i = 1 to 3 do pr#print (string_of_int i) done
;;
</oc-eval>
<p>Le type inféré pour le paramètre <ml>pr</ml> est un type objet.
La seule contrainte est qu'il doit posséder une méthode <ml>print : string -> 'a</ml>.
Les <ml>..</ml> dans le type du paramètre signifient que l'objet peut avoir
n'importe quelles autres méthodes de n'importe quels types, ce
qui compte est la présence d'une méthode <ml>print</ml> avec le type <ml>string -> 'a</ml>.
</p>
<p>
Nous pouvons donc logiquement appeler cette fonction en lui passant en argument
notre objet <ml>err_printer</ml> créé plus haut:
</p>
<oc-eval>hello err_printer</oc-eval>
<p>Mais nous pouvons également lui passer un objet anonyme créé juste pour un appel:</p>
<oc-eval>hello (mk_printer false);;
hello (object method foo = 1 method print _ = print_endline "coucou" end);;
</oc-eval>
<p>Bien sûr, si l'objet passé en paramètre ne vérifie pas les contraintes
de type, le compilateur signale une erreur:
</p>
<oc-eval error-exc="false">hello (object method print n = string_of_int n end);;</oc-eval>
<p>
Pour déterminer la compatibilité de deux types objets, la notion de <strong>sous-typage</strong>
est utilisée. On pourra utiliser un objet d'un type t en lieu et place d'un
objet de type t' si t est un sous-type de t'. Un type objet t est sous-type d'un type objet t' si
toutes les méthodes de t' sont présentes dans t. De plus, pour chacune,
son type dans t doit être un sous-type du type de la même la méthode dans t'.
</p>
<p>
Voyons quelques exemples en définissant une fonction dont nous spécifions
le type du paramètre pour qu'il requiert une méthode <ml>m : int -> int</ml>
tout en permettant à l'objet passé d'avoir d'autres méthodes (grâce aux <ml>..</ml>):
</p>
<oc-eval><![CDATA[let test (p : < m : int -> int ; .. >) = p#m 1;;]]></oc-eval>
<p>Voyons maintenant la compatibilité avec différents objets:</p>
<oc-eval error-exc="false">
(* objet vide, invalide car la methode m requise est absente *)
test (object end);;
(* objet valide, exactement le meme type *)
test (object method m x = x + 1 end);;
(* objet invalide: m n'a pas le bon type *)
test (object method m x = float x end);;
(* objet valide: 'a -> 'a est un sous-type de int -> int *)
test (object method m x = x end);;
(* objet valide: m du bon type et une methode
   supplementaire ne pose pas de probleme *)
test (object method m x = x + 1 method m2 = "hello" end)
</oc-eval>
<p>Ce dernier cas ne passe que parce que le type exigé pour le paramètre
 de la fonction <ml>test</ml> contient <ml>..</ml>, indiquant que les méthodes
 supplémentaires sont acceptées. Sans ces <ml>..</ml>, le dernier cas ne passe
 pas:
</p>
<oc-eval error-exc="false"><![CDATA[let test2 (p : < m : int -> int >) = p#m 1;;
test2 (object method m x = x + 1 method m2 = "hello" end)
]]></oc-eval>
<p>Un <em>cast</em> est alors nécessaire pour dépouiller l'objet de sa méthode
en trop avant de le passer en paramètre. Le <em>cast</em> est réalisé
avec l'opérateur <ml>:&gt;</ml>, qui prend un objet à gauche et un type à droite,
le tout entre parenthèses:
</p>
<oc-eval><![CDATA[let o = object method m x = x + 1 method m2 = "hello" end;;
test2 (o :> < m : int -> int >);;
]]></oc-eval>
<p>Evidemment, dépouiller un objet d'un type t vers un type t' si t n'est
pas un sous-type de t' provoque une erreur:
</p>
<oc-eval error-exc="false"><![CDATA[
let o = object method m = string_of_int end;;
(o :> < m : int -> int >);;
]]></oc-eval>
<p>
On constate que le <strong>système de types d'OCaml ne confond pas sous-typage et héritage</strong>,
puisqu'il n'est pas nécessaire à deux objets d'hériter d'un ancètre commun ou de déclarer
une interface pour pouvoir être utilisés l'un à la place de l'autre lorsque le contexte
le permet.
</p>


<subsection id="funobjects" title="Objets fonctionnels">
<p>
On appelle <em>objets fonctionnels</em> les objets qui, plutôt que mettre
à jour un état interne lors de l'appel d'une méthode, renvoient une copie
d'eux-mêmes avec éventuellement des modifications des valeurs des attributs
de l'objet original.
</p>
<p>
La syntaxe pour construire une copie de l'objet en cours en en changeant
certains attributs est la suivante:
</p>
<centerstx>{&lt; <stxid>attribut1</stxid> = <stxid>expr1</stxid> ; <stxid>attribut2</stxid> = <stxid>expr2</stxid> ; ... &gt;} </centerstx>
<p>
Par exemple, nous pourrions faire un objet représentant une liste de la
façon suivante:
</p>
<oc-eval><![CDATA[let l =
  object
    val value = []
    method value = value
    method cons h = {< value = h :: value >}
    method hd = List.hd value
    method tl = List.tl value
    method map f = {< value = List.map f value >}
  end;;
let l1 = l#cons 1 ;;
let l2  = ((l1#cons 2)#cons 3)#cons 4 ;;
let l3 = l2#map (fun x -> x + 1);;
l3#value;;
]]></oc-eval>
</subsection>

</section>

<section id="classes" title="Classes">
<p>
Nous avons pour l'instant créé des objets sans passer par la définition
de classes. Nous avons également vu qu'il était possible de définir des
fonctions retournant des objets créés à partir de paramètres.
</p>
<p>
L'utilisation d'objets créés de cette façon, si elle est pratique dans
certains cas, est déconseillée à grande échelle, car elle nuit à
la lisibilité et la maintenabilité du logiciel. Etre capable de nommer
et catégoriser les objets et les concepts est important pour les comprendre
et les manipuler<note>"Mal nommer les classes, c'est ajouter de la misère au logiciel",
disait (presque) Camus.</note>.
</p>
<subsection id="classdecl" title="Déclaration">
<p>
La déclaration d'une classe prend la forme suivante:
</p>
<centerstx>class <stxid>identifiant</stxid> [<stxid>paramètres</stxid>] = object <stxid>champs</stxid> end</centerstx>
<p>
L'<stxid>identifiant</stxid> se trouve dans le même espace de nom que les types,
car la définition d'une classe introduit un nouveau type du même nom.
</p>
</subsection>

<subsection id="classparams" title="Paramètres de classes">
<p>
Voyons quelques exemples de déclarations. Tout d'abord une classe sans paramètre
</p>
<oc-eval>
class c1 = object method hello = print_endline "bonjour le monde!" end ;;
</oc-eval>
<p>Ensuite, déclarons une classe <ml>c2</ml> avec deux paramètres, <ml>x</ml>
et <ml>y</ml>, utilisés pour initialiser deux attributs modifiables de mêmes noms.
Nous déclarons également deux méthodes <ml>as_string</ml> et <ml>move</ml>, cette
dernière modifiant les valeurs des deux attributs:
</p>
<oc-eval><![CDATA[class c2 x y =
  object
    val mutable x = x
    val mutable y = y
    method as_string = Printf.sprintf "(%d, %d)" x y
    method move new_x new_y = x <- new_x ; y <- new_y
  end
]]></oc-eval>
<p>
Comme pour les <doc href="fonctionnelle#def">définitions de fonctions</doc>,
la syntaxe que nous avons utilisée est un raccourci pour une syntaxe plus explicite
utilisant le mot-clé <ml>fun</ml>. Nous pouvons définir une classe <ml>c3</ml>
identique à <ml>c2</ml> de la façon suivante:
</p>
<oc-eval><![CDATA[class c3 = fun x -> fun y ->
  object
    val mutable x = x
    val mutable y = y
    method as_string = Printf.sprintf "(%d, %d)" x y
    method move new_x new_y = x <- new_x ; y <- new_y
  end
]]></oc-eval>
<p>
Cette syntaxe permet d'introduire des calculs intermédiaires avant ou entre les
paramètres, lors de l'instanciation. Elle fait également apparaître qu'une classe,
en plus d'un type, définit l'équivalent d'une fonction de construction, prenant
des paramètres et retournant un objet.
</p>
</subsection>

<subsection id="instanciation" title="Instanciation">
<p>
L'instanciation d'un objet selon une classe est réalisée avec le mot-clé
<ml>new</ml> suivi du nom de la classe et tout ou partie des paramètres éventuels
que celle-ci accepte:
</p>
<oc-eval><![CDATA[let o1 = new c1 ;;
o1#hello ;;
let objet_c2 = new c2 3 5 ;;
objet_c2#as_string ;;
objet_c2#move 25 73 ;;
objet_c2#as_string ;;
]]></oc-eval>
<p>
Au passage, on constate que le type indiqué n'est plus de la forme
<ml>&lt; .. &gt;</ml>, mais que par concision le nom de la classe est utilisé
(puisque la déclaration d'une classe entraîne la création d'un type du même nom).
</p>
<p>
Puisque <ml>c2</ml> accepte des paramètres, nous pouvons appliquer partiellement
l'instanciation, en ne fournissant qu'une partie des paramètres:
</p>
<oc-eval><![CDATA[
(* application partielle: aucun parametre n'est donne *)
let mk_c2 = new c2 ;;
(* on donne un parametre a la fonction retournee *)
let mk_c2_10 = mk_c2 10 ;;
(* on fournit le dernier parametre a la fonction mk_c2_10
  qui retourne alors un objet de type c2 *)
let o = mk_c2_10 20 ;;
o#as_string ;;
]]></oc-eval>
<p>
Pour bien comprendre ce qui est calculé et à quel moment, définissons
une classe prenant plusieurs paramètres et insérons entre ces deniers
des affichages:
</p>
<oc-eval>class c4 =
  let () = print_endline "this message is printed at the class declaration time" in
  fun x ->
    let () = print_endline (Printf.sprintf "got x=%d" x) in
    let z = -x in
    fun y ->
      let () = print_endline (Printf.sprintf "got y=%d" y) in
      object
        initializer
          print_endline (Printf.sprintf "initializer: x=%d, y=%d, z=%d" x y z)
      end;;
</oc-eval>
<p>
Le premier affichage est fait dès la déclaration de la classe, car aucun
paramètre attendu n'empêche son évaluation. Voyons le résultat d'applications
partielles successives:
</p>
<oc-eval>let o = new c4 (* o est maintenant une fonction *) ;;
let o2 = o 1 (* x = 1 et en interne z=-1 *);;
let o3 = o2 10 (* y = 10, tous les parametres sont founis, l'objet est cree *);;
</oc-eval>
<p>
La séquence d'instructions (<ml>;</ml>) est interdite avant la partie <ml>object ... end </ml>,
ce qui nous oblige à utiliser la constrution <ml>let () = ... in</ml> pour réaliser
des effets de bord (affichage).
</p>
<p>
La définition de valeurs entre les paramètres, mais surtout avant le
<ml>object ... end</ml> permet de faire des calculs et opérations
avant la création de l'objet. Les résultats de ces calculs peuvent être
utilisés dans les méthodes et surtout dans les attributs, pour leur fournir
des valeurs d'initialisation. Souvenons-nous que l'initialisation d'un
attribut ne peut utiliser la valeur d'un autre attribut lors de la création
de l'objet.
</p>
</subsection>

<subsection id="constructors" title="Constructeurs">
<p>
Il n'y a pas de notion de constructeur pour les objets en OCaml, ou plutôt
il n'y a qu'un seul constructeur, appelé par <ml>new</ml> suivi du nom de la
classe.
</p>
<p>
Il n'y a pas non plus de de surcharge.
Cependant, les paramètres d'une classe peuvent être utilisés pour l'instancier
avec des valeurs différentes selon le contexte.
Les <doc href="stdlib#exooptparams">paramètres optionnels</doc>
sont une façon aisée d'obtenir différentes façons d'instancier une classe:
</p>
<oc-eval session="trash">class point ?(x=0) ?(y=0) () =
  object
    val x = x
    val y = y
    method as_string = Printf.sprintf "(%d, %d)" x y
  end;;
let origin = new point () ;;
let p = new point ~x: 1 ();;
let q = new point ~x: 2 ~y: 3 () ;;
List.iter (fun o -> print_endline o#as_string) [ origin ; p ; q ];;
</oc-eval>
<p>
Le paramètre <ml>()</ml> est nécessaire dans la déclaration pour que le compilateur
puisse distinguer si <ml>new point</ml> attend ou non des paramètres optionnels.
L'application est totale lorsque le paramètre non optionnel est explicitement donné.
</p>
</subsection>

<subsection id="destructors" title="Destructeurs">
<p>
Il n'y a pas de libération explicite des objets. Ces derniers, comme les
autres valeurs OCaml, sont désalloués lorsqu'ils deviennent inaccessibles.
</p>
<p>
Il est cependant possible, comme pour d'autres valeurs OCaml, d'associer
une fonction à appeler lors de la désallocation de l'objet, grâce
à la fonction <ml>finalise</ml> du module <moduledoc name="Gc"/>. Dans l'exemple
ci-dessous, nous créons des objets avec un nom et qui affichent une chaîne
lorsqu'ils sont sur le point d'être libérés:
</p>
<oc-eval session="trash">
class myclass s =
  object(self)
    val name = s
    method on_destroy = print_endline (name^" is being destroyed!")
    initializer
      Gc.finalise (fun o -> o#on_destroy) self
  end
;;
for i = 1 to 3 do
    ignore (new myclass ("object "^string_of_int i))
  done;;
</oc-eval>
<!-- en fait il faut faire deux fois Gc.major() dans notre environnement -->
<ocaml-eval session="trash" show-code="false">Gc.major ();;</ocaml-eval>
<p>Nous forçons la récupération des miettes par le <em>garbage collector</em>:</p>
<oc-eval session="trash">Gc.major ();;</oc-eval>
</subsection>


<subsection id="classexercises" title="Exercices">
<exercice id="exostack" title="Implémentation d'un pile d'entiers">
<p>
Implémenter une pile d'entiers à l'aide d'une classe. L'état de la pile
sera naturellement dans un attribut (variable d'instance) modifiable.
Les méthodes permettront d'effectuer les actions suivantes:
<ml>push : int -> unit</ml>,
<ml>pop : int option</ml>,
<ml>pick : int option</ml> (retourne l'élément en haut de la pile mais sans la modifier),
<ml>is_empty : bool</ml>.
</p>
<p>
Nous implémentons une pile d'entiers car nous verrons le polymorphisme
<doc href="#clpolym">plus loin</doc>.
</p>
<solution>
<oc-eval><![CDATA[
(* implementation d'une pile d'entiers avec une liste *)
class stack =
  object
    val mutable elements = ([] : int list)
    method push n = elements <- n :: elements
    method pop =
      match elements with
        [] -> None
      | h :: q -> elements <- q ; Some h
    method pick =
      match elements with [] -> None | h :: _ -> Some h
    method is_empty = elements = []
  end;;
]]></oc-eval>
</solution>
<oc-eval>
let stack = new stack ;;
List.iter stack#push [ 1 ; 2 ; 3 ; 4 ; 5 ];;
let rec print stack =
  match stack#pop with
    None -> assert stack#is_empty
  | Some n -> print_endline (string_of_int n); print stack
;;
print stack;;
</oc-eval>
</exercice>

<exercice id="exostackfun" title="Implémentation d'un pile avec une classe fonctionnelle">
<p>Implémenter un pile d'entiers à l'aide d'une classe "fonctionnelle" <ml>fun_stack</ml>,
i.e. dont les méthodes retournent un nouvel objet au lieu de faire
un effet de bord sur l'état interne. La classe aura les méthodes suivantes:
<ml>push : int -> fun_stack</ml>,
<ml>pop : (int * fun_stack) option</ml>,
<ml>pick : int option</ml> (retourne l'élément en haut de la pile mais sans la modifier),
<ml>is_empty : bool</ml>.
</p>
<solution>
<oc-eval><![CDATA[class fun_stack =
  object
    val elements = ([] : int list)
    method push n = {< elements = n :: elements >}
    method pop =
      match elements with
        [] -> None
      | h :: q -> Some (h, {< elements = q >})
    method pick =
      match elements with [] -> None | h :: _ -> Some h
    method is_empty = elements = []
  end;;
]]></oc-eval>
</solution>
<oc-eval>
let stack = new fun_stack ;;
let stack = List.fold_left (fun st n -> st#push n) stack [ 1 ; 2 ; 3 ; 4 ; 5 ];;
let rec print stack =
  match stack#pop with
    None -> assert stack#is_empty
  | Some (n, stack) -> print_endline (string_of_int n); print stack
;;
print stack;;
</oc-eval>
</exercice>
</subsection>
</section>


<section id="classrec" title="Classes mutuellement récursives">
<p>
Il peut parfois être utile de définir des classes se connaissant les unes
les autres, de façon à ce que chacune puisse instancier les autres.
De la même façon que pour les types, il suffit d'utiliser le mot-clé <ml>and</ml>
de la façon suivante:
</p>
<oc-eval>class class1 x =
    object
      val x = x
      method make_c2 = new class2 x 10
    end
  and class2 x y =
    object
      method as_string = Printf.sprintf "(%d,%d)" x y
      method c1 = new class1 x
    end;;
let objet_c1 = new class1 42 ;;
let objet_c2 = objet_c1#make_c2;;
objet_c2#as_string ;;
</oc-eval>
</section>


<section id="inheriting" title="Héritage">
<p>
Une classe ou un objet peuvent hériter d'une classe
existante. Par contre, il est impossible d'hériter d'un objet.
</p>
<subsection id="inheritmeca" title="Mécanisme d'héritage">
<p>
L'héritage est introduit par le mot-clé <ml>inherit</ml> suivi d'un
nom de classe et de ses éventuels paramètres. L'exemple suivant,
d'un classicisme éhonté, définit une classe <ml>point</ml> et,
héritant de cette dernière, une classe <ml>colored_point</ml>.
Nous ajoutons des affichages dans les blocs <ml>initializer</ml>
afin de montrer l'ordre d'initialisation:
</p>
<oc-eval><![CDATA[class point ?(x=0) ?(y=0) () =
  object
    val mutable x = x
    val mutable y = y
    method x = x
    method y = y
    method move new_x new_y = x <- new_x ; y <- new_y
    method as_string = Printf.sprintf "(%d,%d)" x y
    initializer
      print_endline (Printf.sprintf "init point with x=%d, y=%d" x y)
  end;;
class colored_point ?(color=0x000) ?x ?y () =
  object(self)
    inherit point ?x ?y () as super
    val mutable color = color
    method color = color
    method set_color c = color <- c
    method as_string = Printf.sprintf "%s[%x]" super#as_string color
    method as_point = (self :> point)
    initializer
      print_endline (Printf.sprintf "init colored_point with x=%d, y=%d, color=%x" x y color)
  end;;
let origin = new point () ;;
let colored_origin = new colored_point ~color: 0xa00 () ;;
origin#as_string ;;
colored_origin#as_string ;;
]]></oc-eval>
<p>
Le champ <ml>inherit point ?x ?y () as super</ml> indique que la classe
<ml>colored_point</ml> hérite de la classe <ml>point</ml> et que, lors
de la création de l'objet de la classe <ml>colored_point</ml>, la partie
correspondant à l'héritage de <ml>point</ml> sera construite avec les
paramètres indiqués (<ml>?x ?y ()</ml>).
</p>
<p>
De plus, le mot-clé <ml>as</ml> permet de donner un identifiant pour faire
appel aux méthodes de la classe héritée. Nous nous en servons dans la redéfinition
de la méthode <ml>as_string</ml>, en faisant appel à <ml>super#as_string</ml>.
</p>
<p>La classe <ml>colored_point</ml> contient également une méthode <ml>as_point</ml>
renvoyant l'objet dépouillé pour être du type <ml>point</ml> (utilisation de l'opérateur
de <em>cast</em> <ml>:&gt;</ml>). Attention cependant, les méthodes qu'il porte
reste celles de la classe <ml>colored_point</ml>:
</p>
<oc-eval>colored_origin#as_point#as_string ;;</oc-eval>
<warning id="warnoverride" title="Redéfinition d'attributs et de méthodes">
<p>
Par défaut, le compilateur n'émet pas d'avertissement lorsqu'une méthode
héritée est masquée par la redéfinition de la méthode dans la classe héritante.
</p>
<p>Un avertissement (le numéro 7) peut être activé pour éviter de redéfinir
par mégarde une méthode. Idem pour un attribut (numéro 13).
Pour éviter l'avertissement quand il est activé, on ajoute un <ml>!</ml>
à <ml>val</ml> ou <ml>method</ml>, signifiant que la redéfinition est volontaire:
</p>
<oc-eval>
#warnings "+7+13";;
class foo =
  object
    inherit point ~x: 0 ~y: 0 ()
    val! mutable x = 0
    val mutable y = 0
    method x = x
    method! as_string = "foo"
  end;;
</oc-eval>
</warning>
<p>
La rédéfinition d'attributs ou de méthodes doit respecter la définition
de la classe héritée: même type et, pour les attributs, même possibilité de modification
ou non.
</p>
</subsection>
<subsection id="inheritmulti" title="Héritage multiple">
<p>
L'héritage multiple est possible, en utilisant plusieurs fois le mot-clé <ml>inherit</ml>.
Les attributs et méthodes sont héritées dans l'ordre d'apparition des
<ml>inherit</ml>, une méthode héritée pouvant être re-définie par une autre méthode
héritée plus loin. Idem pour les attributs.
</p>
<p>
Là encore, on utilisera le <ml>!</ml> après le mot-clé <ml>inherit</ml> pour indiquer
que la redéfinition de méthodes et attributs hérités d'une premère classe, par ceux
d'une seconde classe héritée, est volontaire:
</p>
<oc-eval>class t1 = object val value = 1 method p = "class t1" end;;
class t2 = object method p = "class t2" end;;
class t3 = object val value = 42 end;;
class t4 = object
  inherit t1
  inherit! t2 (* noter le ! *)
  inherit t3 (* l'absence de ! provoque un warning *)
  method value = value
 end;;
print_endline (new t4)#p ;;
(new t4)#value ;;
</oc-eval>
</subsection>
</section>

<section id="classintf" title="Interfaces de classes">
<p>
Les interfaces de classes sont l'équivalent des signatures pour les modules; on
parle en anglais de <em>class types</em>, les types de classes, comme on parle
de types de modules.
</p>
<p>
Une interface de classe liste des attributs et méthodes avec leur type,
mais pas leur valeur:
</p>
<oc-eval>class type ctype =
  object
    val mutable foo : int
    method as_string : string
  end;;
</oc-eval>
<p>
Nous pouvons nous servir d'une telle interface pour restreindre le type
d'une classe:
</p>
<oc-eval>class ma_classe : ctype =
  object
    val mutable foo = 42
    val gee = "hello"
    method as_string = string_of_int foo
  end;;
let o = new ma_classe;;
</oc-eval>
<p>
Si le type de la classe n'est pas un sous-type de l'interface, le compilateur
signale une erreur:
</p>
<oc-eval error-exc="false">class ma_classe : ctype =
  object
    val mutable foo = "hello"
    val gee = "world"
    method as_string = foo
  end;;
</oc-eval>

<p>
Lorsqu'on restreint le type d'un objet, seules les méthodes sont contraintes,
car les attributs de l'objet n'apparaissent pas dans son type:
</p>
<oc-eval error-exc="false">(* as_string est de type 'a, sous-type de string, donc ok *)
let o = object val mutable foo = 42 method as_string = assert false end;;
let (o2 : ctype) = o;;
(* l'absence de l'attribut foo n'est pas un probleme *)
let o3 = object method as_string = "hello" end;;
let (o4 : ctype) = o3;;
(* ici, la methode as_string n'est pas du bon type *)
let o5 = object method as_string = 42 end;;
let (o6 : ctype) = o5;;
</oc-eval>

<warning id="hidingmethods" title="Masquage des méthodes publiques ou virtuelles">
<p>
Il n'est pas possible de masquer, à l'aide d'une contrainte de type, les méthodes
publiques et les <doc href="#virtual">méthodes virtuelles</doc>:
</p>

<oc-eval error-exc="false">class ma_classe : ctype =
  object
    val mutable foo = 42
    method as_string = string_of_int foo
    method hello = print_endline "hello world!"
  end;;
</oc-eval>
</warning>
</section>

<section id="virtual" title="Classes et méthodes virtuelles">

</section>

<section id="clpolym" title="Polymorphisme">
<p>
Les définitions de classes peuvent être paramétrées par des variables
de types:
</p>
<centerstx>class ['a] <stxid>identifiant</stxid> ... = object <stxid>champs</stxid> end
class ['a, 'b, ...] <stxid>identifiant</stxid> ... = object <stxid>champs</stxid> end</centerstx>
</section>

Copie d'objets
Méthodes binaires
</contents>
</module>