<module title="Programmation fonctionnelle"
with-contents="true"
module-name="fonctionnelle"
>
<contents>
<!--<ocaml-eval>#warnings "+3";;</ocaml-eval>-->
<p>
La syntaxe d'OCaml et le paradigme de programmation fonctionnelle
permettent de mieux voir un programme comme une fonction retournant
une valeur calculée à partir de paramètres. Cela
se rapproche des définitions mathématiques des fonctions,
par opposition aux descriptions opérationnelles que l'on trouve
dans les langages impératifs.
</p>
<p>
Illustrons cela avec l'exemple de la fonction factorielle.
Une définition mathématique possible est la suivante:
</p>
<center>
<latex packages="{amsmath,amsfonts,amssymb,amsthm,txfonts}">
\[fact: \mathbb{N}\rightarrow\mathbb{N}; \quad fact(0) = 1 ;\quad fact(n) = n * fact(n-1)\]
</latex>
</center>
<p>
En OCaml, cette fonction sera définie comme ci-dessous;
on notera la ressemblance de syntaxe entre les deux définitions.
</p>
<ocaml><![CDATA[
let rec fact = function
  0 -> 1
| n -> n * fact (n-1);;
]]></ocaml>
<p>
En C, cette fonction pourrait s'écrire:
</p>
<hcode lang="c"><![CDATA[
unsigned int fact (unsigned int n) {
  unsigned int i = 1, res = 1;

  while (i <= n)
   res = res * i++;
  return res;
}]]></hcode>

<section id="noyaufonctionnel" title="Noyau fonctionnel">
<p>
Le noyau fonctionnel du langage permet d'appliquer des fonctions à des valeurs.
Les valeurs sont typées et peuvent être de types de base (entier, flottant, ...,
cf. <doc href="#basetypes"/>), de types plus élaborés construits à partir d'autres
types, ou bien de type fonction. En effet, en OCaml, les fonctions sont des
valeurs <em>de premier ordre</em>, c'est-à-dire que le langage permet de les manipuler
comme d'autres valeurs "simples" comme les entiers. En particulier, on peut définir
des fonctions et les passer en paramètres d'autres fonctions.
</p>

<subsection id="funbase" title="Valeurs, fonctions et types de base">
<subsubsection id="basetypes" title="Types de base">
<p>
Les types ci-dessous sont prédéfinis en OCaml. On donne pour chacun la syntaxe
et des exemples de manipulation.
</p>
<paragraph title="Les entiers (type int)">
<oc-eval id="code-ints" toplevel="true"><![CDATA[
1 (* l'entier 1 *);;
1 + 0xde (* l'addition avec l'opérateur '+', 0xde est la notation hexadécimale*) ;;
3 - 0o11 (* la soustraction, 0o11 est la notation octale *) ;;
4 * 0b10101 (* la multiplication, 0b10101 est la notation binaire *) ;;
10 / 3 (* la division entière *) ;;
(/) 10 3 (* idem, en utilisant l'opérateur en position préfixe *) ;;
( * ) 10 3 (* multiplication; espaces nécessaires pour distinguer des commentaires *);;
15000003 mod 4 (* le modulo, reste de la division entière *) ;;
15_000_003 mod 4 (* même opération, avec un entier plus lisible *) ;;
max_int (* le plus grand entier disponible *) ;;
min_int - 1 (* attention, pas de contrôle sur le dépassement des limites *) ;;
]]></oc-eval>
<p>
<icode>max_int</icode> et <icode>min_int</icode> dépendent de l'architecture de la machine.
Sur une machine 32 bits, les entiers natifs sont codés sur 31 bits, sur 63
bits sur une machine 64 bits. Cela est dû à la façon dont sont encodées les
valeurs.
</p>
<p>
Il existe beaucoup
d'<ext-a href="&lt;urldoccoreint/&gt;">autres opérations</ext-a>
sur les entiers, incluant également les manipulations au niveau bits.
</p>
<p>
On remarquera que l'interprète a automatiquement déterminé le type des expressions
saisies (ici, <icode>int</icode>). C'est ce que l'on appelle l'<em>inférence de type</em>:
le typeur a déduit d'après le code les types des expressions évaluées. Nous verrons
d'autres exemples d'inférence de type au fur et à mesure de la formation.
</p>
</paragraph>

<paragraph id="floats" title="Les flottants (type float)">
<oc-eval id="code-floats" toplevel="true"><![CDATA[
1.0 (* le réel 1.0 *);;
1.0e+5 (* notation avec exposant *) ;;
1.2 +. 1. (* l'addition avec l'opérateur '+.' *) ;;
3.3 -. 2.15 (* la soustraction *) ;;
4. *. 3. (* la multiplication *) ;;
10. /. 3. (* la division *) ;;
(/.) 10. 3. (* idem, en utilisant l'opérateur en position préfixe *) ;;
mod_float 15000003. 4.5 (* le modulo *) ;;
mod_float 15_000_003. 4.5 (* même opération, avec un flottant plus lisible *) ;;
1.999999999 +. 100000000. (* la précision est celle de la norme IEEE 754 *);;
ceil 3.5 (* arrondi à l'entier supérieur *) ;;
floor 3.5 (* arrondi à l'entier inférieur *) ;;
truncate 3.5 (* ne conserve que la partie entière *) ;;
1. /. 0. (* la division par zéro donne l'infini *);;
0. /. 0. (* diviser 0 par 0 ne donne pas un nombre, 'not a number' ou 'NaN' *);;
]]></oc-eval>
<p>
D'autres opérations sont disponibles sur les flottants; on consultera le
<ext-a href="&lt;urldoccorefloat/&gt;">manuel</ext-a>
pour les découvrir.
</p>
<p>
Les opérateurs <icode>+</icode> et <icode>+.</icode> ne sont pas génériques et s'appliquent respectivement
sur des entiers et des flottants (idem pour les autres opérateurs exposés plus haut):
</p>
<oc-eval toplevel="true" error-exc="false"><![CDATA[
1 + 2.0 ;;
1 +. 2.0 ;;
]]></oc-eval>
</paragraph>
<paragraph id="booleans" title="Les booléens (type bool)">
<oc-eval id="code-booleans" toplevel="true"><![CDATA[
true (* la valeur 'vrai' *) ;;
false (* la valeur 'faux' *) ;;
true && false (* ET paresseux séquentiel, evalué de gauche à droite *) ;;
true || false (* OU paresseux séquentiel, evalué de gauche à droite *) ;;
not true (* NON logique *) ;;
]]></oc-eval>
</paragraph>

<paragraph id="chars" title="Les caractères (type char)">
<oc-eval id="code-chars" toplevel="true"><![CDATA[
'a' (* le caractère 'a' *) ;;
int_of_char 'a' (* son code ASCII *) ;;
char_of_int 123 (* le caractère de code ASCII 123 *) ;;
]]></oc-eval>
<p>
D'autres fonctions sont disponibles dans le module <moduledoc name="Char"/>.
</p>
</paragraph>
<paragraph id="strings" title="Les chaînes de caractères (type string)">
<p>
On crée une chaîne de caractères en la mettant entre guillemets <ml>"</ml>:
</p>
<oc-eval toplevel="true">"hello world !";;</oc-eval>
<p>
Le caractère <ml>\</ml> est utilisé pour indiquer des caractères spéciaux:
</p>
<ul>
<li><ml>\"</ml> permet d'insérer le caractère " au lieu de signaler la
fin de la chaîne,</li>
<li><ml>\n</ml> indique une fin de ligne,</li>
<li><ml>\r</ml> indique un retour chariot,</li>
<li><ml>\t</ml> indique une tabulation.</li>
</ul>
<oc-eval toplevel="true"><![CDATA[
print_endline "\"Entre guillemets\"\nune nouvelle ligne";;
]]></oc-eval>
<since-version v="4.02.0">
<p>Une syntaxe alternative peut être utilisée pour éviter de devoir
 «échapper» les caractères spéciaux, en utilisant <ml>{|...|}</ml>
 ou <ml>{id|...|id}</ml>, <ml>id</ml> pouvant être <ml>_</ml> ou
 n'importe quelle suite de lettres en minuscules:
</p>
<oc-eval toplevel="true"><![CDATA[
String.length {|\"|} (* pas d'échappement *);;
{foo||}|foo} (* utilisation d'un délimiteur *);;
{xml|<a href="http://....">bla bla bla</a>|xml};;]]>
</oc-eval>
</since-version>
<p id="lskdfmldskmgksdmgl">
Il est également possible d'utiliser des fonctions créant des chaînes:
</p>
<oc-eval toplevel="true"><![CDATA[
let chaine = String.make 10 'a';;
string_of_int 42;;
string_of_float 84.;;
Printexc.to_string Not_found (* une chaîne à partir d'une exception *);;
"hello " ^ "world!" (* concaténation *);;
]]></oc-eval>
<p id="aopopapop">
Beaucoup d'autres fonctions sont disponibles dans le module <moduledoc name="String"/>:
</p>
<oc-eval id="code-strings" toplevel="true"><![CDATA[
String.length "hello world!" (* longueur de chaîne *);;
String.sub "hello world!" 0 5 ;;
]]></oc-eval>
<p>
L'accès à un caractère d'une chaîne est possible de deux façons, soit en utilisant
la fonction <ml>String.get</ml>, soit en utilisant une syntaxe spéciale,
<ml>chaine.[indice]</ml>. Les indices de caractères commencent à zéro.
</p>
<oc-eval toplevel="true">
String.get "hello world!" 4 (* accès au 5eme caractère *);;
"hello world!".[4]
</oc-eval>
<warning id="noautoconv" title="Pas de conversion automatique">
<p>Il n'existe pas de conversion automatique d'un type vers un autre comme dans
beaucoup d'autres langages interprétés. Ainsi:
</p>
<oc-eval toplevel="true" error-exc="false">
string_of_int 25 (* construction d'une chaîne représentant l'entier 25 *) ;;
3 + "25";;
</oc-eval>
</warning>
<warning id="safe-string" title="Transition vers des chaînes de caractères non mutables">
<before-version-tag v="4.02.0"/>
<p>
Une transition, engagée depuis la version 4.02.0 d'OCaml, aboutira à des chaînes
de caractères non mutables. Dans la version 4.02.0, un nouveau module
<moduledoc name="Bytes"/> et un type <ml>bytes</ml> apparaissent. Ce type
permet de représenter des tableaux d'octets, mutables. Le module fournit
des fonctions similaires aux fonctions du module <moduledoc name="String"/>
et des fonctions de conversion depuis et vers le type <ml>string</ml>.
</p>
<p>En OCaml 4.02.0, les chaînes sont encore mutables, mais une option
<icode>-safe-string</icode> permet de rendre le type <ml>string</ml> non mutable
et les types <ml>bytes</ml> et <ml>string</ml> incompatibles (non unifiables).
Les utilisateurs sont fortement incités à utiliser cette option pour commencer
cette transition. A terme, ce comportement sera celui par défaut.
</p>
<p>Dans cette formation, nous utilisons déjà ce mode, avec des chaînes non
modifiables. Le module <ml>Bytes</ml>, qui concerne une structure de donnée
mutable, est <doc href="imperative#bytes">abordé</doc> dans la partie
relative à la programmation impérative.
</p>
</warning>
</paragraph>

<paragraph id="unit" title="Le type unit">
<p>
<cmp>Le type unit décrit un ensemble ne possédant qu'une seule valeur, notée <icode>()</icode>.</cmp>
</p>
<oc-eval id="code-unit" toplevel="true">();;</oc-eval>
<p>
<cmp>Cette valeur sera plus particulièrement utilisée dans les programmes impératifs
(cf. <doc href="modules/imperative"/>) pour les fonctions qui effectuent des effets
de bord. Les fonctions dont le résultat est la valeur <icode>()</icode> simulent la notion
de procédure qui n'existe pas en OCaml comme le fait le type void dans le langage C.</cmp>
</p>
</paragraph>
<paragraph id="tuples" title="Les n-uplets">
<p>
Les n-uplets permettent de grouper plusieurs valeurs, potentiellement de types différents.
Un n-uplet à 2 éléments est aussi appelé paire. Voici quelques exemples de constructions
de n-uplets:
</p>
<oc-eval id="code-tuples" toplevel="true"><![CDATA[
(1, 2) (* paire d'entiers *) ;;
(1, "2") (* paire composée d'un entier et d'une chaîne *) ;;
fst (1, 2) (* accès a la première composante de la paire *) ;;
snd (1, 2) (* accès a la seconde composante *);;
(1, 2, 3) (* n-uplet de 3 éléments *) ;;
(1.0, "hello", "world", '!') (* n-uplet de 4 éléments de 3 types différents *) ;;
]]></oc-eval>
<p>
On notera que les types des n-uplets inférés sont notés par une '<icode>*</icode>', comme dans
<icode>int * string * string * char</icode>.
</p>
<warning id="warningfstsnd" title="fst et snd">
<p>
Les fonctions <icode>fst</icode> et <icode>snd</icode> ne s'appliquent qu'à des paires et
non à des n-uplets de taille supérieure, comme l'indique le type de ces fonctions:
</p>
<oc-eval toplevel="true" error-exc="false"><![CDATA[
snd;;
fst (1, 2, 3);;
]]></oc-eval>
<p>
La notation <icode>'a * 'b -> 'a</icode> indique qu'il s'agit d'un type fonctionnel (aussi appelé
type "flèche"), décrivant une fonction prenant en argument une paire d'éléments de types quelconques
(<icode>'a * 'b</icode>) et renvoyant une valeur de même type que le premier élément de la paire
(<icode>'a</icode>).
</p>
</warning>
</paragraph>

<paragraph id="lists" title="Les listes (type 'a list)">
<p>
Le type <icode>list</icode> est prédéfini et permet de construire des listes d'éléments de même type.
C'est un type paramétré, <icode>'a</icode> indique le paramètre de type, qui peut être instancié
selon le type des éléments de la liste:
</p>
<oc-eval id="code-lists" toplevel="true" error-exc="false"><![CDATA[
[] (* une liste vide, donc sans contrainte sur le type des éléments *) ;;
[ 1 ] (* une liste d'entiers à un élément *) ;;
[ 1 ; 2 ; 3 ] (* une liste de 3 entiers *) ;;
[ "hello" ; "world" ; "!" ] (* une liste de chaînes *) ;;
[ 1 ; "2" ; 3 ] (* liste invalide car les éléments n'ont pas le même type *) ;;
]]></oc-eval>
<p id="aoppaaaa">
Voyons quelques exemples de manipulation de listes:
</p>
<oc-eval id="code-lists2" toplevel="true"><![CDATA[
1 :: 2 :: 3 :: [] (* ajout d'élément en tête de liste par l'opérateur 'cons' :: *) ;;
[ 1 ; 2 ] @ [ 3 ; 4 ; 5] (* concaténation de deux listes (de même type) *) ;;
List.length [ "hello" ; "world" ; "!" ] (* accès à la longueur *) ;;
List.hd [ 1 ; 2 ; 3 ] (* récupération de l'élément de tête de liste *) ;;
List.tl [ 1 ; 2 ; 3 ] (* récupération de la queue de liste (i.e. sans la tête) *) ;;
String.concat "-" [ "bonjour" ; "le" ; "monde" ] (* concaténation d'une liste de chaînes *) ;;
]]></oc-eval>
<p id="apoopapoa">
Beaucoup d'autres fonctions sont disponibles dans le module <moduledoc name="List"/>.
</p>
</paragraph>
</subsubsection>
</subsection>

<subsection id="comparaisons" title="Comparaisons">
<p>
OCaml offre des fonctions de comparaisons polymorphes, c'est-à-dire opérant sur n'importe
quels types de données, à la seule condition que les valeurs comparées soient du même type.
Elles sont donc de type <icode>'a -&gt; 'a -&gt; bool</icode>, indiquant clairement que le type
des deux arguments doit être le même.
</p>
<p>
Voyons ces fonctions:
</p>
<oc-eval id="code-comparisons" toplevel="true"><![CDATA[
1 = 2 (* égalité structurelle sur des entiers *) ;;
"bonjour" = "monde" (* ... ou sur des chaînes *) ;;
(1, 2, 3) = (1, 2, 4) (* ... ou des n-uplets *) ;;
[ 1 ; 2 ; 3 ] <> [ 1 ; 2 ; 4 ] (* différence structurelle, ici sur des listes *) ;;
not ([ 1 ; 2 ; 3 ] = [ 1 ; 2 ; 4 ])
  (* idem que ci-dessus, en utilisant la négation de l'égalité *) ;;
1 < 2 (* infériorité (structurelle) stricte *) ;;
1 <= 2 (* inférieur ou égal *) ;;
"bonjour" > "monde" (* supérieur *) ;;
[ 1 ; 2 ; 3 ] >= [ 1 ; 2 ] (* supérieur ou egal *) ;;
1 == 2 (* égalité physique *) ;;
1 != 2 (* différence physique *) ;;
]]></oc-eval>
<p>
<cmp>L'égalité structurelle teste l'égalité de deux valeurs en explorant leur structure,
alors que l'égalité physique teste si les deux valeurs occupent la même zone mémoire.
Ces deux égalités retournent le même résultat pour les valeurs simples : booléens,
caractères, entiers et constructeurs constants.</cmp>
</p>
<p>
La comparaison structurelle repose sur l'ordre des entiers pour les entiers, les chaînes
et les caractères (en utilisant les codes ascii), l'ordre naturel sur les flottants.
</p>
</subsection>

<subsection id="conditionnelle" title="Structure de contrôle conditionnelle">
<p>
La syntaxe de la conditionnelle peut prendre deux formes:
</p>
<centerstx id="stxif">if <stxid>expression de type bool</stxid> then <stxid>expression</stxid>
if <stxid>expression de type bool</stxid> then <stxid>expression1</stxid> else <stxid>expression2</stxid>
</centerstx>
<p>
La première forme, sans écriture de la branche <ml>else</ml>, est en fait évaluée comme
</p>
<centerstx id="stxif2">if <stxid>expression de type bool</stxid> then <stxid>expression</stxid> else ()</centerstx>
<p>
Le typage correct de l'expression toute entière impose que les expressions des
branches <ml>then</ml> et <ml>else</ml> soient du même type. En effet, si ce n'était pas
le cas, l'expression entière aurait un type différent selon que l'expression de
condition est vraie ou fausse. L'expression toute entière est donc du même type
que celui des branches.
</p>
<p>
Pour cette raison, l'expression du <ml>then</ml> de la première forme doit être de
type <ml>unit</ml>, car l'expression de la branche <ml>else</ml> implicite
est <ml>()</ml>, qui est de type <ml>unit</ml>.
</p>
<p id="aopipoqpo">
Voyons quelques exemples:
</p>
<oc-eval id="code-conditionnelle" toplevel="true" error-exc="false"><![CDATA[
if true then 1 lsl 5 + 10 else 1
  (* lsl est le décalage logique de bits vers la gauche *) ;;
(if 12 * 4 < 40 then 15 else 2) + (if 3 > 4 then 10 else 4 * 10)
  (* une expression conditionnelle est aussi une expression dont le calcul
     retourne une valeur. *);;
if true then 1;;
]]></oc-eval>
<p>
La dernière expression est un exemple d'expression mal typée, car les types
des branches <ml>then</ml> et <ml>else</ml> diffèrent, ce que signale l'interprète:
l'expression <ml>1</ml> est de type entier alors qu'on attend ici une expression
de type <ml>unit</ml> (comme la branche <ml>else</ml>).
</p>
</subsection>

<subsection id="decl" title="Déclarations de valeurs">
<p>
Les déclarations de valeurs sont des associations entre un nom (un <em>identifiant</em>)
et une valeur. L'obtention de la valeur nécessite le calcul de l'expression
de la définition de l'identifiant. On dit que la valeur est liée (en anglais <em>bound</em>)
au nom dans l'environnement.
Les identifiants sont de la forme suivante: <icode>[a-z_][0-9A-Za-z_']*</icode>, c'est-à-dire
qu'ils peuvent contenir les caractères 'a' à 'z', 'A' à 'Z', '0' à '9', <icode>_</icode>
et <icode>'</icode> mais doivent commencer par une lettre minuscule ou le caractère <icode>_</icode>.
</p>
<p>
Il existe deux types de déclarations: globales et locales.
</p>

<subsubsection id="declglob" title="Déclarations globales">
<p id="oiaopoiapoi">
La syntaxe est la suivante:
</p>
<centerstx id="srclet">let <stxid>identifiant</stxid> = <stxid>expression</stxid>;;</centerstx>
<p>
La valeur résultant du calcul de l'<icode>expression</icode> est ensuite associée à
l'<icode>identifiant</icode>. Cet identifiant est alors connu et peut être utilisé dans
toutes les expressions qui suivent dans le programme. Il est alors remplacé dans
ces expressions par sa valeur associée:
</p>
<oc-eval id="code-declglob" toplevel="true"><![CDATA[
let x = 1 ;;
let y = 41 ;;
let z = x + y ;;
]]></oc-eval>
<p>
Il est impossible d'utiliser un identifiant inconnu:
</p>
<oc-eval toplevel="true" error-exc="false"><![CDATA[foo + 1]]></oc-eval>
<p>
Le message indique que la valeur <ml>foo</ml> n'est pas liée dans l'environnement.
</p>
<p>
On remarquera qu'il est syntaxiquement impossible de déclarer un nom sans valeur. Cela
est fait exprès pour éviter des problèmes de variables non initialisées comme en C:
</p>
<hcode lang="c">void foo () { int toto ; ... }</hcode>
<p>
Dans la fonction C ci-dessus, on peut déjà utiliser la variable <icode>toto</icode> sans savoir
à quoi elle fait référence, ce qui peut provoquer des erreurs d'exécution aléatoires.
</p>
</subsubsection>

<subsubsection id="decllocal" title="Déclarations locales">
<p>
Il est possible de déclarer localement des valeurs. Le nom de la valeur n'est alors
visible que dans une seule expression. La syntaxe est la suivante:
</p>
<centerstx id="stxletloc">let <stxid>identifiant</stxid> = <stxid>expression_1</stxid> in <stxid>expression_2</stxid></centerstx>
<p>
La valeur de l'<stxid>expression_1</stxid> est calculée et liée à
l'<stxid>identifiant</stxid>. Ce dernier n'est visible que dans l'<stxid>expression_2</stxid>. Exemple:
</p>
<oc-eval id="code-decllocal" toplevel="true" error-exc="false"><![CDATA[
let foo = (* déclaration globale foo *)
    let bar =
      let glop = 1 in (* déclaration locale de glop *)
        glop + 2
    in (* déclaration locale de bar, glop n'est plus visible *)
      let gee = bar + 1 in (* déclaration locale de gee, utilisant bar *)
        gee + bar + 2 (* utilisation de gee et bar locales *);;
let buz = bar + foo (* bar n'est plus visible ici *) ;;
]]></oc-eval>
<p>
L'indentation ci-dessus permet de bien voir l'imbrication des expressions. Cependant,
elle prend davantage de place en largeur. On trouvera souvent cette seconde indentation,
n'ajoutant pas de décalage supplémentaire après un <ml>in</ml>:
</p>
<oc-eval toplevel="true"><![CDATA[
let foo =
    let bar =
      let glop = 1 in
      glop + 2
    in
    let gee = bar + 1 in
    gee + bar + 2;;
]]></oc-eval>
<p>
Des conseils sur l'indentation sont <ext-a href="&lt;urldocindentconseils/&gt;">disponibles ici</ext-a>.
</p>
<warning id="warninglocaldecl" title="Déclarations locales et globales">
<p>
Une déclaration locale (<ml>let ... = ... in ...</ml>)
ne peut englober une déclaration globale (<ml>let ... = ... ;;</ml>):
</p>
<oc-eval toplevel="true" error-exc="false">let x = 1 in let y = 2;;</oc-eval>
</warning>
</subsubsection>

<subsubsection id="recdecl" title="Déclarations simultanées">
<p>
Il est possible de déclarer simultanément plusieurs valeurs globales:
</p>
<centerstx id="stxletrec">let <stxid>ident_1</stxid> = <stxid>expression_1</stxid>
and <stxid>ident_2</stxid> = <stxid>expression_2</stxid>
...
and <stxid>ident_N</stxid> = <stxid>expression_N</stxid>;;</centerstx>
<p id="aopiopaipoiapo">
ou locales:
</p>
<centerstx id="stxletrec2">let <stxid>ident_1</stxid> = <stxid>expression_1</stxid>
and <stxid>ident_2</stxid> = <stxid>expression_2</stxid>
..
and <stxid>ident_N</stxid> = <stxid>expression_N</stxid> in
<stxid>expression</stxid></centerstx>
<p>
Les valeurs ne deviennent cependant visibles qu'après toutes les déclarations
simultanées:
</p>
<oc-eval id="code-declsimul" toplevel="true" error-exc="false"><![CDATA[
let x_int = 1
and x_float = 1.0;;
let y_int = 2
and y_float = float_of_int y_int;;
]]></oc-eval>
<p>
Une autre façon de définir plusieurs valeurs en même temps est d'utiliser la
notation des n-uplets:
</p>
<oc-eval id="code-declsimul2" toplevel="true" error-exc="false"><![CDATA[
let (a, b, c) = (1, 2, 3);;
let (a, b) = (1, 2, 3);;
let (a, b, c) = (1, 2);;
]]></oc-eval>
<p>
Contrairement à d'autres langages, le compilateur veille à ne pas avoir de variable
non initialisée comme cela serait le cas pour <ml>c</ml> dans <ml>let (a, b, c) = (1, 2)</ml>.
Les valeurs de l'expression de définition ne sont pas non plus "recyclées" comme
dans le langage R (ce qui aurait donné la valeur <ml>1</ml> à <ml>c</ml> dans notre exemple).
</p>
<p>
Enfin, dans <ml>let (a, b) = (1, 2, 3)</ml>, le compilateur nous indique clairement
que la construction n'est pas correcte puisque nous avons un n-uplet de taille 3
à droite alors que nous le <em>filtrons</em> par un n-uplet de taille 2. Nous verrons
le filtrage en détail dans la section <doc href="#filtrage"/>.
</p>
</subsubsection>
</subsection>

<subsection id="expr" title="Expressions fonctionnelles, fonctions">
<p>
<cmp>Une expression fonctionnelle est constituée d'un paramètre et d'un corps.
Le paramètre formel est un nom de variable et le corps une expression.
On dit que le paramètre est abstrait. C'est pour cela qu'une expression
fonctionnelle est aussi appelée abstraction.</cmp>
</p>
<subsubsection id="def" title="Définition de fonctions">
<p>
On définit une fonction par la syntaxe suivante:
</p>
<centerstx>function <stxid>identifiant</stxid> -&gt; <stxid>expression</stxid></centerstx>
<p>
Une fonction ne prend qu'un seul paramètre. Cependant, elle peut renvoyer à son
tour une valeur fonctionnelle, ce qui permet de simuler des fonctions à plusieurs
paramètres:
</p>
<centerstx>function <stxid>identifiant_1</stxid> -&gt; function <stxid>identifiant_2</stxid> -> <stxid>expression</stxid></centerstx>
<p id="aooaooaa">
Voyons quelques exemples de définition de fonctions:
</p>
<oc-eval id="code-funs" toplevel="true"><![CDATA[
function x -> x * x (* la fonction carré sur les entiers *) ;;
function x -> function y -> x +. y (* l'addition sur les flottants *) ;;
fun x y -> x +. y (* raccourci syntaxique pour l'expression ci-dessus *)
]]></oc-eval>
<p>
On remarquera le type de ces expressions, inféré automatiquement par l'interprète.
Les types des valeurs fonctionnelles sont notés avec <ml>-></ml>. Ainsi,
<ml>int -> int</ml> indique une valeur fonctionnelle prenant en paramètre
une valeur de type <ml>int</ml> et retournant une valeur de type <ml>int</ml>.
</p>
<p>
Le type <ml>float -> float -> float</ml> est équivalent à
<ml>float -> (float -> float)</ml> (associativité à droite de <ml>-></ml>), ce qui signifie
que la valeur prend en paramètre un <ml>float</ml> et retourne une valeur fonctionnelle
de type <ml>float -> float</ml> qui elle aussi prend un <ml>float</ml> mais retourne
une valeur de type <ml>float</ml>.
</p>
</subsubsection>

<subsubsection id="app" title="Application de fonctions">
<p>
L'application d'une fonction à une valeur s'écrit en juxtaposant une valeur
fonctionnelle et un paramètre:
</p>
<oc-eval id="code-funs2" toplevel="true"><![CDATA[(function x -> x + 1) 41 ;;
((function x -> function y -> x +. y) 1.0) 41.0 ;;
(function x -> function y -> x +. y) 1.0 41.0 (* suppression des parenthèses inutiles *) ;;
]]></oc-eval>
<p>
Dans la dernière expression ci-dessus, nous supprimons les parenthèses inutiles car
l'application est associative à gauche, c'est-à-dire que le premier paramètre
<ml>1.0</ml> est appliqué à <ml>function x -> ...</ml>, ce qui revient donc à calculer
l'expression <ml>(function y -> 1.0 +. y)</ml> (le paramètre <ml>x</ml> est remplacé
par la valeur <ml>1.0</ml> à laquelle est appliquée la fonction); la valeur obtenue est encore
une fonction qui est alors appliquée à <ml>41.0</ml> pour finalement calculer
<ml>1.0 +. 41.0</ml>.
</p>
<p>
Il est donc possible d'appliquer un seul paramètre à la même valeur fonctionnelle:
</p>
<oc-eval id="code-funs3" toplevel="true"><![CDATA[(function x -> function y -> x +. y) 1.0;;]]></oc-eval>
<p>
Le résultat est une expression fonctionnelle. Cet aspect est parfois appelé
<em>application partielle</em> quand on considère la fonction comme ayant deux paramètres
<ml>x</ml> et <ml>y</ml>.
</p>
<p>
L'expression <ml>function (x, y) -> ...</ml> n'est pas équivalente
à <ml>function x -> function y -> ...</ml>. En effet, dans la première on définit une fonction
prenant en paramètre un couple, tandis que la seconde définit une fonction retournant une
fonction, ce qui revient à une fonction à deux paramètres.
</p>
<p>
Le mode d'évaluation de l'application en OCaml est le passage par valeur, c'est-à-dire
que l'expression en paramètre d'une fonction est d'abord évaluée et ensuite cette
valeur est passée à la fonction pour évaluer cette dernière. Cela est différent du
passage par nom. Ainsi, dans l'expression
</p>
<oc-eval toplevel="true"><![CDATA[(function x -> x+1) (24 + 17)]]></oc-eval>
<p>
l'expression <ml>24 + 17</ml> est d'abord évaluée et la valeur <ml>41</ml> est passée à
la fonction pour en évaluer le corps.
</p>
<p>
La valeur de retour d'une fonction est la valeur de l'expression du corps de la fonction.
</p>
<p>
Les fonctions définies et appliquées "au vol" sont appelées fonctions anonymes, car
elles ne sont pas liées à un identifiant. Bien souvent, on nommera les fonctions pour
les appliquer plus tard, en effectuant des déclarations globales ou locales:
</p>
<oc-eval id="code-funs4" toplevel="true"><![CDATA[
let square = function x -> x * x (* fonction carré sur les entiers *) ;;
let add = fun x y -> x + y (* en utilisant le raccourci de syntaxe *) ;;
let sub = function x -> function y -> x - y ;;
let sub x y = x - y (* idem en utilisant un autre raccourci de syntaxe *) ;;
]]></oc-eval>
<p>
Enfin, le compilateur effectue des vérifications de type lors de l'application de fonction,
comme nous l'avons vu précédemment sur les opérateurs arithmétiques.
Voyons quelques exemples corrects et incorrects:
</p>
<oc-eval id="code-funs5" toplevel="true" error-exc="false"><![CDATA[
square 24 ;;
square 24.0 (* erreur: le paramètre doit être un entier *) ;;
(square 1) 2 (* erreur (square 1) n'est pas une fonction et ne peut être appliquée *) ;;
let add1 = add 1 (* application "partielle" de add pour obtenir une fonction d'incrément *) ;;
add1 41 ;;
]]></oc-eval>
<warning id="parenth" title="Place des parenthèses">
<p>
Les parenthèses ne peuvent être mises n'importe où:
</p>
<oc-eval id="code-parenth" toplevel="true" error-exc="false"><![CDATA[let f x y = x + y ;;
f 1 2 ;;
(f 1) 2 ;;
(f 1 2) ;;
((f 1) 2) ;;
f ( 1 ) 2 ;;
f 1 ( 1 + 1);;
f ( 0 + 1 ) ( 2 + 0 );;
f (1 2);;
]]></oc-eval>
</warning>
</subsubsection>

<subsubsection id="closures" title="Fermetures">
<p>
Considérons l'exemple suivant:
</p>
<oc-eval id="code-closures" toplevel="true"><![CDATA[
let increment = 2;;
let add_increment x = x + increment ;;
add_increment 1 ;;
let increment = 20 ;;
add_increment 1 ;;
]]></oc-eval>
<p>
Nous constatons que la valeur retournée par <ml>add_increment 1</ml> ne varie pas,
même après avoir redéfini la variable <ml>increment</ml>.
</p>
<p>
Ce comportement, qui est celui souhaité, est obtenu grâce aux fermetures. Une fermeture
(en anglais <em>closure</em>) est composée d'une fonction et de son environnement,
c'est-à-dire les valeurs liées à des identifiants au moment de la définition de fonction.
</p>
<p>
En OCaml, la définition d'une expression fonctionnelle entraîne la création
d'une fermeture pour garantir ce comportement, et c'est cette fermeture qui est
retournée. Lors de l'application d'une fonction, la valeur du paramètre
est associée au paramètre et le corps de la fonction est évalué dans l'environnement
conservé dans la fermeture enrichi par la valeur liée au paramètre.
</p>
</subsubsection>

<subsubsection id="infix" title="Opérateurs infixes">
<p>
Nous avons vu comment définir des fonctions <em>préfixes</em>, c'est-à-dire qu'elles sont
positionnées avant les expressions sur lesquelles elles sont appliquées, comme dans
<ml>add 30 12</ml>.
</p>
<p>
Il est parfois plus lisible d'avoir des fonctions s'appliquant à deux paramètres et dont
l'application s'écrira plus naturellement avec le nom de la fonction
entre ses paramètres. C'est le cas des opérateurs
arithmétiques vus précédemment: il est plus habituel d'écrire <ml>1 + 2</ml> que
<ml>+ 1 2</ml>.
</p>
<p>
Il est possible en OCaml de définir de tels opérateurs, en utilisant les parenthèses
autour de l'identifiant et en utilisant pour ce dernier certains caractères réservés:
</p>
<oc-eval toplevel="true"><![CDATA[
let (++) (x, y) n = (x + n, y + n);;
(2, 0) ++ 2 (* utilisation en position infixe *) ;;
(++) (2, 0) 2 (* utilisation en position préfixe *) ;;
]]></oc-eval>
<p>
Les caractères réservés à ce genre de définition sont
<ext-a href="http://caml.inria.fr/pub/docs/manual-ocaml/lex.html">indiqués ici</ext-a>.
</p>
</subsubsection>

<subsubsection id="higher" title="Ordre supérieur">
<p>
<cmp>Une valeur fonctionnelle (une fermeture) peut être retournée comme résultat.
Elle peut également être prise comme argument d'une fonction. Les fonctions prenant
en argument ou retournant des valeurs fonctionnelles sont dites d'ordre supérieur.</cmp>
Par exemple:
</p>
<oc-eval id="code-higher" toplevel="true"><![CDATA[let h = function f -> function y -> (f y) + y ;;
]]></oc-eval>
<p>
La bibliothèque standard est pleine de fonctions d'ordre supérieur, souvent polymorphes.
Ainsi, la fonction <ml>List.map</ml> prend en paramètres une fonction et une liste et applique
la fonction à chaque élément de la liste pour construire une nouvelle liste:
</p>
<oc-eval id="code-higher2" toplevel="true"><![CDATA[List.map ;;
List.map square [ 1 ; 2 ; 3 ; 4 ; 5 ; 6 ];;
]]></oc-eval>
</subsubsection>
</subsection>

<subsection id="recur" title="Récursion">
<p>
L'ajout à l'environnement d'une variable globale ou locale est fait à la fin de la déclaration.
Il est donc impossible d'utiliser la variable dans sa définition, puisqu'elle n'est pas
encore dans l'environnement:
</p>
<oc-eval id="code-recur" toplevel="true" error-exc="false"><![CDATA[
let compte x = if x <= 0 then x else compte (x-1) + 1;;
]]></oc-eval>
<p>
Pour pouvoir déclarer des valeurs <em>récursives</em> (qui font appel à elles-mêmes), il
faut explicitement les indiquer comme telles, en utilisant le mot-clé <ml>rec</ml>:
</p>
<oc-eval id="code-recur2" toplevel="true"><![CDATA[let rec compte x = if x <= 0 then x else compte (x-1) + 1;;
compte 10;;
]]></oc-eval>
<p>
Il est également possible de définir des valeurs mutuellement récursives globales:
</p>
<oc-eval id="code-recur3" toplevel="true"><![CDATA[
let rec triple x = if x <= 0 then 0 else triple_aux (x - 2) + 1
and triple_aux x = triple (x+1) + 2;;
triple 20;;
]]></oc-eval>
<p id="aoipoipoiapoi">
ou locales:
</p>
<oc-eval toplevel="true" error-exc="false"><![CDATA[
let rec triple2 x = if x <= 0 then 0 else triple2_aux (x - 2) + 1
and triple2_aux x = triple2 (x+1) + 2 in
triple2 20;;
triple2 30;;
]]></oc-eval>
</subsection>

<subsection id="polyconst" title="Polymorphisme et contrainte de type">

<subsubsection id="polymorphisme" title="Polymorphisme">
<p>
<cmp>Les fonctions dont l'un des paramètres ou la valeur de retour
est d'un type qu'il n'est pas nécessaire de préciser sont dites
polymorphes. Le synthétiseur de types contenu dans le compilateur d'OCaml
trouve le type le plus général pour chaque expression. Dans ce cas, OCaml
utilise des variables, ici 'a et 'b, pour désigner ces types généraux.
Ces variables sont instanciées par le type de l'argument lors de
l'application de la fonction.</cmp>
</p>
<p>
<cmp>Avec les fonctions polymorphes d'OCaml nous cumulons les avantages
de pouvoir écrire un code générique utilisable pour des valeurs de
tout type, tout en conservant la sûreté d'exécution du typage statique.
En outre, la vérification des types est effectuée à la compilation, donc
la généricité du code ne nuit pas à l'efficacité du programme.
</cmp></p>
<p>
Quelques exemples:
</p>
<oc-eval toplevel="true"><![CDATA[
fst ;;
fst (1, 'a');;
fst ("hello", 1.2);;
List.map ;;
square ;;
List.map square [ 1 ; 2 ; 3 ; 4 ; 5 ; 6 ];;
string_of_int ;;
List.map string_of_int [ 1 ; 2 ; 3 ; 4 ; 5 ; 6 ];;
]]></oc-eval>
</subsubsection>

<subsubsection id="const" title="Contrainte de type">
<p>
Il est possible de forcer le type des valeurs, ce qui est utile dans plusieurs cas:
</p>
<ul>
<li>pour améliorer la lisibilité du programme, en indiquant explicitement les
types des paramètres d'une fonction par exemple,</li>
<li>pour n'autoriser l'utilisation d'une valeur que dans un certain contexte,</li>
<li>pour indiquer quel type devra prendre une valeur modifiable
 (cf. chapitre <doc href="imperative"/>); en effet, lors de leur création certaines valeurs
 ne permettent pas de déterminer leur type (par exemple la liste vide <ml>[]</ml>),
 ce qui pose problème lorsqu'il s'agit de données modifiables: le compilateur doit
 pouvoir vérifier qu'on n'affecte pas une valeur du mauvais type à une donnée modifiable,</li>
<li>pour comprendre un problème de type signalé par le compilateur: en indiquant
explicitement les types attendus, le typeur peut signaler au plus tôt les conflits de
type.</li>
</ul>
<p>
Les contraintes de types d'une variable sont notées ainsi:
</p>
<centerstx>( <stxid>identifiant</stxid> : <stxid>type</stxid> )</centerstx>
<p>
Exemple:
</p>
<oc-eval toplevel="true" error-exc="false"><![CDATA[
let (mon_map : ('a -> int) -> 'a list -> int list) = List.map;;
mon_map square [ 1 ; 2 ; 3 ; 4 ; 5 ; 6 ];;
mon_map string_of_int [ 1 ; 2 ; 3 ; 4 ; 5 ; 6 ];;
mon_map int_of_string [ "1" ; "2" ; "3" ; "4" ; "5" ; "6" ];;
]]></oc-eval>
<warning id="forcepoly" title="Contrainte et polymorphisme">
<p>
Il n'est pas possible de forcer le type d'un identifiant à être polymorphe
là où il ne l'est pas:
</p>
<oc-eval toplevel="true" error-exc="false"><![CDATA[let (f : 'a -> 'a -> int) = fun x y -> x + 1;;]]></oc-eval>
</warning>
</subsubsection>
</subsection>

<subsection id="exercices" title="Exercices">
<p>
On pourra s'aider de la documentation du module <moduledoc name="List"/>.
</p>
<exercice id="redeflistmap" title="Redéfinition de List.map">
<p>
Réécrire la fonction <ml>List.map</ml>, prenant en paramètres une fonction <latex>f</latex> et une liste
d'éléments et retournant une nouvelle liste, résultat de l'application de <latex>f</latex> à chaque élément.
La fonction conserve l'ordre des éléments. On utilisera la récursion et les fonctions
<ml>List.length</ml>, <ml>List.tl</ml>, <ml>List.hd</ml> et le constructeur <ml>::</ml>.
</p>
<solution>
<oc-eval toplevel="true"><![CDATA[
let rec map f l =
  if List.length l <= 0 then
    []
  else
    (f (List.hd l)) :: (map f (List.tl l));;
map string_of_int [ 1 ; 2 ; 3 ; 4 ; 5 ; 6];;
]]></oc-eval>
</solution>
</exercice>

<exercice id="minint" title="Le plus petit entier">
<p id="aoiopiapopaa">
Ecrire une fonction prenant une liste d'entiers et retournant le plus petit ou
<ml>max_int</ml> si la liste est vide.
</p>
<solution>
<oc-eval toplevel="true"><![CDATA[let min_elt = List.fold_left min max_int;;
min_elt [ 10 ; 4 ; 45; 69 ; 2 ; 13 ];;
min_elt [];;
]]></oc-eval>
</solution>
</exercice>

<exercice id="average" title="Moyenne d'une liste">
<p id="auuauyu">
Ecrire une fonction prenant une liste d'entiers et retournant la moyenne sous
forme d'un flottant, ou <ml>0.</ml> si la liste est vide.
</p>
<solution>
<oc-eval toplevel="true"><![CDATA[let avg list =
  if List.length list > 0 then
    let sum = List.fold_left (+) 0 list in
    (float sum) /. (float (List.length list))
  else
    0.0;;
avg [ 10 ; 4 ; 45; 69 ; 2 ; 13 ];;
avg [];;
]]></oc-eval>
</solution>
</exercice>
</subsection>
</section>

<section id="decltypesfilt" title="Déclaration de types et filtrage de motifs">
<subsection id="filtrage" title="Filtrage de motif (pattern matching)">
<p>
Le filtrage permet:
</p>
<ul>
<li>d'effectuer des traitements adaptés selon la structure et le contenu d'une valeur,</li>
<li>d'accéder à une partie d'une valeur en la déconstruisant.</li>
</ul>
<p>
Les motifs s'expriment dans une syntaxe presque identique à celle des expressions,
bien qu'il ne soit pas question d'évaluation mais de test sur la structure et
le contenu des valeurs filtrées.
Le terme anglais pour le filtrage est <em>pattern matching</em>.
</p>
<div id="patternsyntax">
<p id="aoiuoia">
La syntaxe est la suivante:
</p>
<centerstx>match <stxid>expression_0</stxid> with
 | <stxid>pattern_1</stxid> -> <stxid>expression_1</stxid>
 | <stxid>pattern_2</stxid> -> <stxid>expression_2</stxid>
 | ...
</centerstx>
</div>
<p>
L'évaluation de cette expression se déroule ainsi:
L'<stxid>expression_0</stxid> est évaluée. Sa valeur est ensuite comparée au premier motif
<stxid>pattern_1</stxid>. Si la valeur est filtrée (elle correspond aux contraintes de ce motif), alors
l'<stxid>expression_1</stxid> est évaluée en une valeur qui est la valeur de toute la construction
<ml>match ... with</ml>. Si ce n'est pas le cas, la valeur de <stxid>expression_0</stxid> est comparée
au motif <stxid>pattern_2</stxid>, et ainsi de suite jusqu'à ce qu'un motif corresponde à la valeur.
</p>
<p>
Si aucun motif ne correspond à la valeur à filtrer, une exception (cf. <doc href="#exceptions"/>)
<ml>Match_failure</ml> est levée. Pour se prémunir contre cette erreur de programmation qui correspond
à un cas non prévu par le programmeur, deux solutions:
</p>
<ul>
<li>utiliser un motif "attrape-tout" exprimé par <ml>_</ml>,</li>
<li>s'assurer que les motifs permettent d'attraper tous les cas; ce travail
est facilité par le compilateur OCaml qui signale les constructions <ml>match ... with</ml>
non-exhaustives et donne un exemple de valeur non filtrée.</li>
</ul>
<p>
Les motifs permettent à la fois
</p>
<ul>
<li>d'exprimer des contraintes sur la valeur filtrée,</li>
<li>de lier de nouveaux identifiants à des parties de la valeur filtrée.</li>
</ul>
<p>
Voyons maintenant quelques exemples:
</p>
<oc-eval id="code-pattern-int" toplevel="true"><![CDATA[match 1 + 1 with
  0 -> print_endline "bizarre"
| 1 -> print_endline "etrange"
| 2 -> print_endline "ouf!"
;;
]]></oc-eval>
<p>
Dans l'exemple ci-dessus, l'expression <ml>1 + 1</ml> est évaluée et ensuite comparée
jusqu'à trouver un motif lui correspondant, ici <ml>2</ml>, ce qui provoque l'évaluation
de l'expression <ml>print_endline "ouf!"</ml>. Le compilateur émet un avertissement
indiquant que la construction de filtrage n'est pas exhaustive, en exhibant un cas
non filtré, la valeur <ml>3</ml>.
</p>
<oc-eval id="code-pattern-list" toplevel="true"><![CDATA[
match List.map string_of_int [ 1 ; 2 ; 3 ] with
  []
| _ :: [] -> assert false
| [s1 ; s2] -> assert false
| s1 :: s2 :: s3 :: _ ->
    List.iter print_endline [ s1 ; s2 ; s3 ]
| l ->
    List.iter print_endline l
;;
]]></oc-eval>
<p>
Dans cet exemple, nous filtrons une valeur de type <ml>string list</ml>. Les premier
(<ml>[]</ml>) et deuxième (<ml>_::[]</ml>) motifs filtrent respectivement
la liste vide et n'importe quelle liste à un élément, et
partagent le même traitement associé (<ml>assert false</ml><note>La fonction <ml>assert</ml> prend
en paramètre une expression de type <ml>bool</ml> et lève une exception
<ml>Assertion_failed</ml> si l'expression est évaluée à <ml>false</ml>.</note>).
Le troisième motif <ml>[s1 ; s2]</ml> filtre les listes à deux éléments, en liant le
premier élément à l'identifiant <ml>s1</ml> et le second à l'élément <ml>s2</ml>. Dans
notre exemple, la liste filtrée aura toujours trois éléments donc nous ne passerons
jamais dans cette branche.
</p>
<p>
Le motif <ml>s1 :: s2 :: s3 :: _</ml> filtre toutes les listes d'au moins trois éléments.
Il utilise l'opérateur de construction de liste <ml>::</ml> (appelé <em>cons</em>), avec à
gauche un élément et à droite une liste. Dans ce motif, les trois premiers éléments
de la liste sont associés aux identifiants <ml>s1</ml>, <ml>s2</ml> et <ml>s3</ml>. Les
identifiants créés dans un motif ne sont visibles que dans l'expression associée à ce
motif.
</p>
<p>
Enfin, OCaml nous indique que le dernier motif <ml>l</ml>, qui permet de filtrer n'importe
quelle liste en l'associant à l'identifiant <ml>l</ml>, est inutile car les motifs
précédents permettent de filtrer tous les cas possibles.
</p>
<p>
Une erreur fréquente lorsqu'on commence à utiliser la structure de filtrage
est d'utiliser un identifiant pour imposer une contrainte d'égalité avec un
identifiant prédéfini:
</p>
<oc-eval toplevel="true"><![CDATA[let x = 3;;
match [ 0 ] with
  [x] -> true
| _ -> false
]]></oc-eval>
<p>
Ce n'est pas l'effet attendu. Le <ml>x</ml> du motif <ml>[x]</ml> crée une nouvelle
liaison dans l'environnement entre un nouvel identifiant <ml>x</ml> et la valeur <ml>0</ml>.
Il n'est fait aucune comparaison avec l'identifiant <ml>x</ml> précédemment défini.
La bonne façon de faire sera d'utiliser une clause <ml>when</ml> permettant d'ajouter
une expression de type <ml>bool</ml> à un motif. Dans ce cas, l'expression associée
au motif (à droite de <ml>-></ml>) ne sera exécutée que si l'expression est évaluée à vraie.
Si ce n'est pas le cas, l'effet sera le même que si le motif ne correspondait pas
à la valeur filtrée, et l'évaluation de la structure de filtrage passera au motif suivant:
</p>
<oc-eval toplevel="true"><![CDATA[match [ 0 ] with
| [y] when y = x -> true
| _ -> false
;;
]]></oc-eval>
<p>
A noter que l'on n'écrira pas:
</p>
<oc-eval id="code-badmatch" toplevel="true"><![CDATA[match [ 0 ] with
| [x] when x = x -> true
| _ -> false
;;]]></oc-eval>
<p>
car les deux <ml>x</ml> de <ml>x = x</ml> font référence tous deux à l'identifiant créé
dans le motif <ml>[x]</ml>. Les clauses <ml>when</ml> sont également appelées
<em>gardes</em>.
</p>
<warning id="multiplebind" title="Pas de liaisons multiples">
<p>
Il n'est pas possible de lier plusieurs fois la même variable dans un motif, y compris
pour exprimer une contrainte d'égalité entre deux parties de l'expression filtrée:
</p>
<oc-eval toplevel="true" error-exc="false"><![CDATA[match (1,2) with
  (x,x) -> true
| _ -> false
;;]]></oc-eval>
</warning>
<p>
Le mot clé <ml>as</ml> permet de créer un nouvel identifiant pour tout ou partie d'un motif:
</p>
<oc-eval toplevel="true"><![CDATA[match [ [ 1 ; 2 ] ; [ 3 ; 4 ] ] with
  [ [ 1 ; 2 ] as liste1 ; liste2 ] as tout ->
   List.iter print_int liste1;
   print_newline();
   List.iter (fun l -> List.iter print_int l) tout;
   print_newline();
| _ -> assert false
;;]]></oc-eval>
<p>
Nous verrons d'autres exemples de filtrage dans la suite du document, car cette construction
est très utilisée.
</p>
</subsection>

<subsection id="ex2" title="Exercice">
<exercice id="palindromlist" title="Liste palindrome">
<p>
Définir une fonction prenant en paramètre une liste d'éléments quelconques et
retournant vrai si la liste est un palindrome, faux sinon.
</p>
<solution>
<oc-eval toplevel="true"><![CDATA[let palindrome_list l =
  let len = List.length l in
  let rec iter n = function
    [], [] -> true
  | h1::q1, h2::q2 ->
    (n > len / 2) || ( (h1 = h2) && iter (n + 1) (q1, q2) )
  | _ -> assert false (* les listes en paramètre ont la même longueur *)
  in
  iter 0 (l, List.rev l)
;;
]]></oc-eval>
</solution>
<p>
Quelques tests:
</p>
<oc-eval toplevel="true"><![CDATA[palindrome_list [1 ; 2 ; 3 ; 2 ; 1 ];;
palindrome_list ['1' ; '2' ; '3' ; '3' ; '2' ; '1' ];;
palindrome_list ['r' ; 'a' ; 'd' ; 'a'; 'r'];;
palindrome_list ['r' ; 'a' ; 'v' ; 'e'; 'r'];;
palindrome_list [1.0 ; 2.0 ; 3.0 ; 4.0 ; 2.0 ; 1.0];;
palindrome_list [];;
]]></oc-eval>
</exercice>
</subsection>

<subsection id="declfilt" title="Déclaration de valeurs par filtrage d'un motif">
<p>
Il est possible d'utiliser le <em>pattern-matching</em> pour déclarer plusieurs
variables en même temps, en filtrant le résultat d'une expression:
</p>
<oc-eval id ="code-declfilt" toplevel="true" error-exc="false"><![CDATA[
let (x, y, z) = (1, "2", 3.0);;
let [s1 ; s2 ; s3] = [ "un" ; "deux" ; "trois"];;
let [x1 ; x2] = [ 1 ; 2 ; 3 ] ;;
]]></oc-eval>
</subsection>

<subsection id="decltypes" title="Déclaration de types">
<p>
OCaml permet de définir ses propres types de données, en plus de ceux de base.
La syntaxe est la suivante:
</p>
<centerstx>type <stxid>identifiant</stxid> = <stxid>définition</stxid></centerstx>
<p>
Les types mutuellement récursifs seront définis de la façon suivante:
</p>
<centerstx>type <stxid>identifiant_1</stxid> = <stxid>définition_1</stxid>
and <stxid>identifiant_2</stxid> = <stxid>définition_2</stxid>
...
and <stxid>identifiant_N</stxid> = <stxid>définition_N</stxid>
</centerstx>
<p>
On remarquera qu'il n'y a pas de mot-clé <ml>rec</ml> pour les définitions de type,
chaque type pouvant être récursif sans syntaxe particulière.
</p>
<since-version v="4.02.2">
<p>Cependant, le mot-clé <ml>nonrec</ml> permet d'avoir une définition explicitement
non récursive, c'est-à-dire que le type introduit n'est pas connu dans sa définition:
</p>
<oc-eval error-exc="false">
type nonrec my_tree = Node of my_tree list | Value of int
</oc-eval>
</since-version>
<p>
Les identifiants de types ont la même syntaxe que les identifiants de valeurs, mais
sont dans un espace de noms différent, ce qui signifie que l'on peut définir une
valeur <ml>foo</ml> et un type <ml>foo</ml> sans problème.
</p>
<p>
Les paramètres des types paramétrés doivent être indiqués avant l'identifiant:
</p>
<centerstx>type 'a <stxid>identifiant</stxid> = <stxid>définition utilisant le paramètre de type 'a</stxid>
type ('a, 'b) <stxid>identifiant</stxid> = <stxid>définition utilisant 'a et 'b</stxid>
</centerstx>
<p id="aioyauyuyua">
Ainsi, on peut définir le type des listes de paires d'éléments d'un type en paramètre:
</p>
<oc-eval id="code-decltypes" toplevel="true"><![CDATA[type 'a pairs = ('a * 'a) list;;
let int_pair_list = [ (1, 2) ; (5, 4) ] ;;
let (int_pairs : int pairs) = [ (1, 2) ; (3, -3) ; (6, 8)];;
let (bool_pairs : bool pairs) = [ (true, true) ; (false, false) ; (true, false)];;
]]></oc-eval>
<p>
Ce type étant défini uniquement à partir de types existants, nous devons indiquer explicitement
le type que nous voulons voir apparaître, sinon le compilateur infère le type à partir des types
de base, comme pour <ml>int_pair_list</ml> ci-dessus. Cependant, nous pouvons utiliser
indifféremment des valeurs de type <ml>'a pairs</ml> ou du type <ml>('a * 'a) list</ml>, le compilateur
réalisant l'unification de ces types pour vérifier qu'ils sont bien compatibles:
</p>
<oc-eval id="code-decltypes2" toplevel="true"><![CDATA[
(=);;
int_pair_list;;
int_pairs;;
int_pair_list = int_pairs;;
]]></oc-eval>
<p>
Si les types ne sont pas compatibles, le compilateur signale une erreur:
</p>
<oc-eval id="code-decltypes3" toplevel="true" error-exc="false"><![CDATA[
let (float_pairs : float pairs) = [ (1., 2.) ; (3., 4.)];;
int_pairs = float_pairs;;
]]></oc-eval>
</subsection>

<subsection id="records" title="Enregistrements">
<subsubsection id="records:decl" title="Définition d'un type">
<p><cmp>Les enregistrements sont des n-uplets dont chaque champ est nommé
à la manière des <icode>record</icode> de Pascal ou des <icode>struct</icode> de C.
Un enregistrement correspond toujours à la déclaration d'un nouveau type. Un type
enregistrement est défini par la déclaration de son nom, du nom de chacun
de ses champs et de leur type.</cmp>
</p>
<p id="auytyayiuao">
La syntaxe est la suivante:
</p>
<centerstx id="stxtypevars">type [<stxid>variables de type</stxid>] <stxid>identifiant</stxid> = {
  <stxid>nom_de_champ_1</stxid> : <stxid>type_1</stxid> ;
  ...
  <stxid>nom_de_champ_n</stxid> : <stxid>type_n</stxid> ;
}</centerstx>
<p>
Un type enregistrement ne peut avoir deux noms de champs identiques.
</p>
</subsubsection>
<subsubsection id="records:create" title="Création de valeurs">
<p>
Par mesure de sûreté, le compilateur impose que chaque champ soit initialisé, lors de la création
d'une valeur de type enregistrement. Cela évite des problèmes de champs non initialisés comme
on peut en rencontrer en langage C.
</p>
<p>
On peut créer une valeur d'un type enregistrement de deux façons:
</p>
<ul>
<li>soit à partir de rien, avec la syntaxe suivante:
<centerstx>{ champ_1 = <stxid>expression_1</stxid> ; ... ; champ_n = <stxid>expression_n</stxid> }</centerstx>
</li>
<li>soit à partir d'une autre valeur du même type, en modifiant certains champs:
<centerstx>{ <stxid>identifiant</stxid> with champ_i = <stxid>expression_i</stxid> ; ... ; champ_j = <stxid>expression_j</stxid> } </centerstx>
</li>
</ul>
<p>
L'ordre dans lequel le contenu des champs est défini est sans importance. Cependant, on aura à cœur
de définir les champs toujours dans le même ordre afin de faciliter la lecture et la maintenance
du programme. Par ailleurs, l'ordre d'évaluation lors de l'affectation des champs n'étant
pas spécifié, on ne se reposera pas dessus si celles-ci ont des effets de bord (lors de
l'utilisation de traits impératifs du langage).
</p>
</subsubsection>
<subsubsection id="records:access" title="Accès aux champs">
<p>
L'accès à un champ d'une valeur de type enregistrement se fait en utilisant le point '<ml>.</ml>'
entre l'identifiant de la valeur et le nom du champ. Ainsi, <ml>foo.bar.gee</ml> représente
l'accès à la valeur du champ <ml>gee</ml> de la valeur du champ <ml>bar</ml> de la valeur <ml>foo</ml>.
</p>
</subsubsection>
<subsubsection id="records:filt" title="Filtrage">
<p id="apoipoipaopio">
Il est bien sûr possible d'utiliser le filtrage sur des valeurs de type enregistrement,
en mettant des contraintes sur tout ou partie des champs du type:
</p>
<centerstx>match <stxid>expression</stxid> with
{ champ_i = <stxid>motif_i</stxid> ; ... ; champ_y = <stxid>motif_y</stxid> } -> ...
</centerstx>
</subsubsection>
<subsubsection id="records:exemple" title="Exemple">
<p id="aiouoiuoai">
Voici un exemple de définition et d'utilisation d'un type enregistrement <ml>coord</ml>
avec deux champs <ml>x</ml> et <ml>y</ml>, tous deux de type <ml>float</ml>:
</p>
<oc-eval id="code-records" toplevel="true" error-exc="false"><![CDATA[
type coord = { x : float ; y : float};;
let origin = { x = 0. ; y = 0. };;
let add p1 p2 = { x = p1.x +. p2.x ; y = p1.y +. p2.y };;
let unite = { x = 1. ; y = 1. };;
let unite_x = { unite with y = 0. };;
let p1 = add (add origin unite) unite;;
p1 = unite;;
match add p1 unite with
  { x = mon_x } as foo when foo.y > 1. -> string_of_float mon_x
| { x = x ; y = y } -> string_of_float (x +. y);;
]]></oc-eval>
</subsubsection>
</subsection>

<subsection id="variants" title="Types somme">
<subsubsection id="variants:decl" title="Définition d'un type">
<p><cmp>À la différence des n-uplets ou des enregistrements, qui correspondent à un produit
cartésien, la déclaration d'un type somme correspond à une union d'ensembles. On regroupe
dans un même type des types différents (par exemple des entiers et des chaînes de
caractères). Les différents membres de la somme sont discriminés par des constructeurs qui
permettent d'une part, comme leur nom l'indique, de construire les valeurs de ce type
et d'autre part d'accéder aux composantes de ces valeurs grâce au filtrage de motif.
Appliquer un constructeur à un argument, c'est indiquer que la valeur retournée appartient à ce nouveau type.
</cmp>
</p>
<p><cmp>On déclare un type somme en donnant le nom de ses constructeurs et le type de leur éventuel argument.</cmp>
</p>
<p id="aiouoiauoi">
La syntaxe est la suivante:
</p>
<centerstx id="stxtypevars2">type [<stxid>variables de type</stxid>] <stxid>identifiant</stxid> =
  <stxid>Constructeur_1</stxid>
  ...
| <stxid>Constructeur_i</stxid> of <stxid>type_i</stxid>
  ...
| <stxid>Constructeur_n</stxid> of <stxid>type_n1</stxid> * ... * <stxid>type_nm</stxid>
</centerstx>
<p>
Les noms des constructeurs doivent commencer par une majuscule.
</p>
<p>
Chaque constructeur d'un type somme peut avoir 0, 1 ou plusieurs paramètres, dont le type est indiqué
dans la définition du type somme.
</p>
<p>
Un type somme ne peut avoir deux constructeurs de même nom.
</p>
<p id="aopipapoipoa">
Voici un exemple de définition d'un type somme:
</p>
<oc-eval id="code-variants" toplevel="true"><![CDATA[
type direction =
  Nord
| Sud
| Est
| Ouest
| Compose of direction * direction;;
]]></oc-eval>
</subsubsection>
<subsubsection id="variants:create" title="Création de valeurs">
<p>
Une valeur d'un type somme est créée à l'aide d'un constructeur de ce type et des paramètres
adaptés selon le constructeur, par la syntaxe suivante:
</p>
<ul>
<li>pour un constructeur sans paramètre: <stxid>Constructeur</stxid>,</li>
<li>pour un constructeur avec un paramètre: <stxid>Constructeur</stxid> <stxid>expression</stxid>,</li>
<li>pour un constructeur avec n paramètres:
 <centerstx><stxid>Constructeur</stxid> (<stxid>expression_1</stxid>,...,<stxid>expression_n</stxid>)</centerstx>
</li>
</ul>
<p>
Avec notre exemple de type <ml>direction</ml>, cela donne par exemple:
</p>
<oc-eval id="code-variants-create" toplevel="true"><![CDATA[let nne = Compose (Nord, Compose (Nord, Est));;]]></oc-eval>
</subsubsection>

<subsubsection id="variants:filt" title="Filtrage">
<p id="apoipopopa">
Il est bien sûr possible d'utiliser le filtrage sur des valeurs de type somme,
en procédant par cas sur les constructeurs du type:
</p>
<centerstx>match <stxid>expression de type somme</stxid> with
| <stxid>Constructeur_1</stxid> -> <stxid>expression_1</stxid>
| <stxid>Constructeur_i</stxid> <stxid>motif_i</stxid> -> <stxid>expression_i</stxid>
| <stxid>Constructeur_j</stxid> (<stxid>motif_j1</stxid>, ..., <stxid>motif_jn</stxid>) -> <stxid>expression_j</stxid>
...
</centerstx>
<p>
Par exemple:
</p>
<oc-eval id="code-variants-filt" toplevel="true"><![CDATA[
let rec string_of_direction = function
  Nord -> "nord"
| Sud -> "sud"
| Est -> "est"
| Ouest -> "ouest"
| Compose (d1, d2) -> (string_of_direction d1)^"-"^(string_of_direction d2);;
string_of_direction nne;;
]]></oc-eval>
</subsubsection>

<subsubsection id="variants:exo" title="Exercice">
<exercice id="exoexpr" title="Représentation d'expressions arithmétiques">
<p>
Définir un type somme <ml>expr</ml> pour représenter les expressions contenant les
4 opérations habituelles sur les entiers ainsi que les valeurs entières. On aura
donc 5 constructeurs.
</p>
<solution>
<oc-eval toplevel="true"><![CDATA[
type expr =
  Val of int
| Add of expr * expr
| Sub of expr * expr
| Mul of expr * expr
| Div of expr * expr;;
]]></oc-eval>
</solution>
<p>
Ensuite, définir une fonction prenant une valeur de ce type et calculant la
valeur entière en réalisant l'opération décrite.
</p>
<solution>
<oc-eval toplevel="true"><![CDATA[
let rec eval = function
  Val n -> n
| Add (e1, e2) -> (eval e1) + (eval e2)
| Sub (e1, e2) -> (eval e1) - (eval e2)
| Mul (e1, e2) -> (eval e1) * (eval e2)
| Div (e1, e2) -> (eval e1) / (eval e2)
;;
eval (Add (Val 2, Mul (Val 4, Sub (Val 12, Val 2))));;
]]></oc-eval>
</solution>
</exercice>
</subsubsection>
</subsection>
<subsection id="typescope" title="Portée des déclarations">
<p>
Les déclarations de type ont la même portée que les déclarations globales de variables et peuvent
comme elles être masquées par de nouvelles déclarations avec des noms similaires.
Cependant, les valeurs définies avec un type <ml>t</ml> ne changent pas de type en cas
de définition d'un nouveau type <ml>t</ml> (et heureusement!). Par contre, ces homonymies peuvent
rendre les messages d'erreur du compilateur un peu déroutants:
</p>
<oc-eval id="poaoppoiopa" toplevel="true" error-exc="false"><![CDATA[
type t = Foo | Bar;;
let x = Foo;;
type t = Gee | Buz;;
let y = Gee;;
x = y;;
]]></oc-eval>
<p>
Le même phénomène de masquage est possible sur les noms des champs des types enregistrements.
Cependant, depuis la version 4.01.0 d'OCaml, les informations de typage sont utilisées pour
lever les possibles ambiguïtés. Ainsi, dans l'exemple ci-dessous, lors de la définition
de <ml>y</ml>, le type de <ml>x</ml> est déjà connu comme étant <ml>rec1</ml>, ce qui
permet au système de type de comprendre <ml>champ = 3</ml> comme le champ <ml>champ</ml>
du type <ml>rec1</ml> et non du type <ml>rec2</ml>:
</p>
<oc-eval toplevel="true"><![CDATA[
type rec1 = { champ : int; champ2: int };;
let x = { champ = 0 ; champ2 = 1;};;
type rec2 = { champ : int ; champ3 : int};;
let y = { x with champ = 3 };;
]]></oc-eval>
<p>
De même sur les noms des constructeurs de types sommes dans l'exemple ci-dessous.
Le type de <ml>x</ml>
étant <ml>t</ml>, le constructeur <ml>Foo</ml> dans le filtre est compris
comme le constructeur <ml>Foo</ml> du type <ml>t</ml> et non de <ml>t2</ml>.
Le compilateur indique donc que le cas où la valeur est construite avec <ml>Bar</ml>
n'est pas traité.
</p>
<oc-eval id="pooaipoipoa" toplevel="true"><![CDATA[
type t = Foo | Bar;;
let x = Foo;;
type t2 = Foo;;
match x with
| Foo -> 0;;
]]></oc-eval>
<p>
Même avec ce système de désambiguation, il est souvent utile de choisir des noms "à préfixe"
pour les champs et les constructeurs, par exemple:
</p>
<oc-eval toplevel="true"><![CDATA[
type user = { user_name : string; user_login: string};;
type host = { host_name : string; host_ipv4: int * int * int * int};;
]]></oc-eval>
<p>
Même si cela est plus verbeux, cela facilite la lecture et la maintenance des programmes.
</p>
</subsection>
<subsection id="funtypes" title="Types fonctionnels">
<p>
Les types fonctionnels sont les types représentant des fonctions, comme nous en avons
déjà vu précédemment. Il est possible de créer ses propres types fonctionnels ou encore
d'utiliser des types fonctionnels pour les champs d'enregistrements ou les paramètres
de constructeurs.
</p>
<p id="poipapoiuuauua">
Ainsi, on peut définir le type d'un afficheur de messages:
</p>
<oc-eval toplevel="true"><![CDATA[
type printer = string -> unit;;
]]></oc-eval>
<p>
Tout comme il est possible d'avoir des champs fonctionnels dans un type enregistrement:
</p>
<oc-eval id="apoipoaiuyy" toplevel="true"><![CDATA[
type output_context = {
  output_error : string -> unit ;
  output_message : string -> unit ;
}]]></oc-eval>
<p>
ou bien, en utilisant notre type <ml>printer</ml>:
</p>
<oc-eval id="auyuaiyuiy" toplevel="true"><![CDATA[
type output_context = {
  output_error : printer ;
  output_message : printer ;
}
]]></oc-eval>
<p>
On peut également avoir des paramètres fonctionnels pour des constructeurs:
</p>
<oc-eval toplevel="true"><![CDATA[
type action =
  Init of (unit -> output_context)
| Compute of (unit -> unit)
| Terminate of (unit -> unit);;
]]></oc-eval>
<p>
Ces valeurs fonctionnelles peuvent être nommées dans des motifs de filtrage pour être appliquées:
</p>
<oc-eval toplevel="true"><![CDATA[
let action = Compute (fun () -> print_endline "coucou");;
match action with
  Compute f -> f () (* application de la fonction f à () *)
| Init f -> ignore(f())
| Terminate f -> f();;
]]></oc-eval>
</subsection>
<subsection id="funtypesexo" title="Exercice">
<exercice id="funtypesexercice" title="Expressions génériques">
<p>
On souhaite rendre les expressions de l'<exercice href="exoexpr"/> génériques. Pour cela, ajouter
un paramètre de type au type <ml>expr</ml> pour ne plus limiter les valeurs des
expressions à des entiers.
</p>
<solution>
<oc-eval toplevel="true"><![CDATA[
type 'a expr =
  Val of 'a
| Add of 'a expr * 'a expr
| Sub of 'a expr * 'a expr
| Mul of 'a expr * 'a expr
| Div of 'a expr * 'a expr;;
]]></oc-eval>
</solution>
<p>
Ensuite, on veut pouvoir paramétrer la fonction <ml>eval</ml> pour spécifier le traitement
à effectuer pour chaque opérateur de notre type expression. Définir un type enregistrement
<ml>operators</ml> permettant de donner la fonction associée à chaque opérateur d'expression.
Ce type est paramétré par le type des valeurs calculées.
</p>
<solution>
<oc-eval toplevel="true"><![CDATA[
type 'a operators = {
  op_add : 'a -> 'a -> 'a ;
  op_sub : 'a -> 'a -> 'a ;
  op_mul : 'a -> 'a -> 'a ;
  op_div : 'a -> 'a -> 'a ;
};;
]]></oc-eval>
</solution>
<p>
Enfin, définir une nouvelle fonction <ml>eval</ml> prenant en paramètre supplémentaire
les fonctions à utiliser pour effectuer les calculs lors de l'évaluation (une valeur
de type <ml>operators</ml>).
</p>
<solution>
<oc-eval toplevel="true"><![CDATA[
let rec eval ops = function
  Val v -> v
| Add (e1, e2) -> ops.op_add (eval ops e1) (eval ops e2)
| Sub (e1, e2) -> ops.op_sub (eval ops e1) (eval ops e2)
| Mul (e1, e2) -> ops.op_mul (eval ops e1) (eval ops e2)
| Div (e1, e2) -> ops.op_div (eval ops e1) (eval ops e2)
;;
]]></oc-eval>
</solution>
<p>
Définir une valeur du type <ml>operators</ml> et s'en servir pour évaluer une expression
contenant des flottants.
</p>
<solution>
<oc-eval toplevel="true"><![CDATA[
let float_ops = {
  op_add = (+.) ;
  op_sub = (-.) ;
  op_mul = ( *. ) ;
  op_div = (/.) ;
};;
eval float_ops (Add (Val 2., Mul (Val 4., Sub (Val 12., Val 2.))));;
]]></oc-eval>
</solution>
</exercice>
</subsection>
</section>

<section id="domain" title="Typage, domaine de définition et exceptions">
<p><cmp>Le type inféré d'une fonction correspond à un sur-ensemble de son domaine
de définition. Ce n'est pas parce qu'une fonction prend un paramètre de type <ml>int</ml>
qu'elle saura calculer une valeur pour tous les entiers passés en argument. On
traite en général ce problème en utilisant le mécanisme d'exceptions d'OCaml. Le
déclenchement d'une exception provoque une rupture du calcul qui peut être interceptée
et traitée par le programme. Pour cela l'exécution du programme doit avoir posé un
récupérateur d'exception avant le calcul de l'expression qui provoque le
déclenchement de cette exception.</cmp>
</p>

<subsection id="exceptions" title="Fonctions partielles et exceptions">
<p><cmp>Le domaine de définition d'une fonction correspond à l'ensemble des valeurs sur
lesquelles la fonction effectue son calcul.</cmp>
</p>
<p>
Que faire quand est passée à une fonction une valeur qu'elle ne sait pas traiter ?
Retourner une valeur arbitraire n'est pas la bonne solution. Les exceptions sont faites pour
gérer ces situations. Par exemple, la fonction <ml>List.hd</ml> récupérant le premier
élément d'une liste lèvera une exception <ml>Invalid_argument</ml> si une liste vide
lui est passée.
</p>
<p>
Une fonction peut être partielle parce qu'elle ne traite pas toutes les formes possibles d'un
paramètre:
</p>
<oc-eval toplevel="true"><![CDATA[
type dummy = One | Two | Three;;
let succ = function
  One -> Two
| Two -> Three
;;
]]></oc-eval>
<p>
Le compilateur signale que la fonction est partielle, en indiquant que la structure de filtrage
ne traite pas le cas <ml>Three</ml>. En effet, l'application de cette fonction à la valeur <ml>Three</ml>
déclenchera une exception prédéfinie pour ce genre de cas:
</p>
<oc-eval toplevel="true" error-exc="false">succ Three;;</oc-eval>
<p>
Ce genre d'exception n'est pas très facile à traiter car il est utilisé pour n'importe quel
<em>pattern-matching</em> non exhaustif. On préférera donc définir et utiliser
ses propres exceptions afin d'être en mesure de traiter efficacement et précisément chaque erreur.
</p>
<p>
Les exceptions prédéfinies et utilisées par les modules de la bibliothèque standard d'OCaml
sont indiquées
<ext-a href="&lt;urldoccoretypes/&gt;">ici</ext-a>.
</p>
</subsection>
<subsection id="exc:def" title="Définition d'une exception">
<p>
Une nouvelle exception est définie avec la syntaxe
</p>
<centerstx>exception <stxid>Identifiant</stxid></centerstx>
<p>
L'identifiant doit commencer par une majuscule, comme pour les constructeurs de type somme.
On peut également définir une exception portant une valeur d'un type indiqué à la définition:
</p>
<centerstx>exception <stxid>Identifiant</stxid> of <stxid>type</stxid></centerstx>
<p>
ce qui permet de passer de l'information sur les causes, l'endroit et les conditions menant à
ce comportement exceptionnel.
</p>
<oc-eval toplevel="true"><![CDATA[
exception Mon_erreur of string
]]></oc-eval>
<p>
Les exceptions peuvent être vues comme des valeurs d'un type somme
<ml>exn</ml> qui serait enrichi à chaque création d'exception:
</p>
<oc-eval toplevel="true">Mon_erreur "message"</oc-eval>
<p>
Remarque: le type d'une exception ne peut être polymorphe.
</p>
</subsection>
<subsection id="exc:raise" title="Déclenchement d'une exception">
<p>
Une exception est déclenchée (ou levée) grâce à la fonction <ml>raise</ml> prédéfinie:
</p>
<oc-eval toplevel="true" error-exc="false">raise (Mon_erreur "Ceci n'est pas un message d'erreur");;</oc-eval>
<p>
Nous pouvons redéfinir notre fonction <ml>succ</ml> pour lever une exception appropriée:
</p>
<oc-eval toplevel="true"><![CDATA[
let succ = function
  One -> Two
| Two -> Three
| Three -> raise (Mon_erreur "Je ne sais pas compter plus loin")
;;
]]></oc-eval>
<p>
La levée d'une exception interrompt l'évaluation normale de l'expression qui la contient.
Cela peut avoir de l'importance lorsque l'ordre d'évaluation n'est pas spécifié, comme
dans l'exemple suivant:
</p>
<oc-eval toplevel="true" error-exc="false"><![CDATA[
let f x =
  (* l'affichage, trait impératif par excellence,
     n'est là que pour montrer l'ordre d'exécution *)
  print_endline (Printf.sprintf "Appel de f avec x = %d" x);
  if x < 0 then
    raise (Mon_erreur "c'est negatif !")
  else
    x + 1;;
(f (-1)) + (f 1);;
]]></oc-eval>
<p>
On constate ici que l'ordre d'évaluation des arguments passés à une fonction (ici
l'opérateur infixe <ml>(+)</ml>) est de droite à gauche. Cela signifie que nous avons
tout de même effectué une partie du calcul avant de lever l'exception. De telles
situations peuvent rendre plus difficile la correction d'un programme. On s'appliquera
parfois, pour se prémunir contre de telles situations, à forcer l'ordre d'évaluation
des paramètres avant de les passer à la fonction:
</p>
<oc-eval toplevel="true" error-exc="false"><![CDATA[
let p1 = f (-1) in
let p2 = f 1 in
p1 + p2;;
]]></oc-eval>
<p>
On se trouve ici au bord de la programmation impérative.
</p>
</subsection>
<subsection id="exc:try" title="Récupération d'une exception">
<p>
La construction suivante permet de récupérer (on dit aussi "attraper") une
exception levée dans l'<stxid>expression</stxid>:
</p>
<centerstx>try <stxid>expression</stxid>
with
  <stxid>motif_1</stxid> -> <stxid>expression_1</stxid>
| ...
| <stxid>motif_n</stxid> -> <stxid>expression_n</stxid>
</centerstx>
<p>
Dans la partie <ml>with</ml>, on donne des motifs de filtrage d'exception, qui fonctionnent
de la même façon que les motifs de filtrage de valeurs. Concrètement, on pourra écrire
comme suite de notre exemple:
</p>
<oc-eval toplevel="true"><![CDATA[
try ignore(succ Three)
  with
    Mon_erreur s -> print_endline ("Erreur: "^s)
  | Failure s ->  print_endline ("Failure: "^s);;
]]></oc-eval>
<p>
Contrairement au filtrage sur des valeurs, le compilateur ne peut ici indiquer si
les motifs du bloc <ml>with</ml> sont exhaustifs. Cela nécessiterait de connaître
toutes les exceptions potentiellement levées à chaque point du code, ce qui demanderait
une analyse de flots de données, notamment à cause des possibilités de passage de
fonction en paramètre. En effet, une telle fonction pourrait lever une exception,
mais, dans bien des situations, le paramètre effectif ne sera connu qu'à l'exécution.
</p>
<p>
Par ailleurs, on ne souhaite pas forcément rattraper toutes les exceptions possibles
à chaque point d'un programme, mais plutôt rattraper seulement certaines,
que l'on peut traiter, en laissant volontairement remonter celles correspondant
à des cas plus inattendus dans lesquels on ne peut rien faire d'autre qu'interrompre
le traitement en cours.
</p>
<p>
Il est possible de rattraper toutes les exceptions avec le motif universel '<ml>_</ml>', ou
bien en liant l'exception rattrapée à un identifiant, comme ci-dessous:
</p>
<oc-eval toplevel="true" error-exc="false"><![CDATA[
try List.hd []
with
  e ->
    (* traitement effectué pour n'importe quelle exception *)
    print_endline "An exception was caught!";
    let msg =
      match e with
        Failure s | Sys_error s -> s
      | _ -> Printexc.to_string e
    in
    print_endline ("Some info about the exception: "^msg);
    (* relançons l'exception *)
    raise e;;
]]></oc-eval>
<since-version v="4.02.0">
<p id="matchwithexception">La construction <ml>match ... with</ml>
permet également de rattraper des exceptions
en utilisant le mot-clé <ml>exception</ml> dans les motifs. Si une exception est levée
lors de l'évaluation de l'expression entre le <ml>match</ml> et le
<ml>with</ml>, alors elle pourra être rattrapée par un motif d'<ml>exception</ml>.
L'expression associée à un tel motif doit bien sûr être du même type que les
autres branches pour que l'expression <ml>match ... with</ml> soit correctement typée.
Voyons un exemple:
</p>
<oc-eval toplevel="true">
match List.assoc "z" [ "x", 1 ; "y", 2 ] with
| exception Failure msg ->
    assert false (* cette exception n'est pas censée être levée par List.assoc *)
| exception Not_found ->
    None (* aucune valeur n'est associée à "z" *)
| n -> Some n;;
</oc-eval>
<p>On peut ajouter plusieurs motifs pour rattraper des exceptions, et on peut
les mettre à n'importe quelle position dans la liste des motifs. Si une exception
est levée, alors le premier motif <ml>exception</ml> dans la liste et qui
correspond à l'exception levée attrape l'exception et l'expression associée
est évaluée. Si aucun motif <ml>exception</ml> n'attrape l'exception, alors
cette dernière est propagée dans l'expression englobante.
</p>
<warning id="matchexceptionbranches"
 title="Branches normales et branches &lt;ml&gt;exception&lt;/ml&gt;">
<p>
On ne peut pas "mettre en commun" une expression sous
un motif <ml>exception</ml> et un autre motif, que cela soit un autre motif
<ml>exception</ml> ou un motif filtrant
la valeur retournée par l'expression entre le <ml>match</ml> et le
<ml>with</ml>:
</p>
<oc-eval toplevel="true" error-exc="false">
match String.sub "hello" 0 12 with
  | exception Invalid_argument str
  | exception Failure str -> str
  | str -> str;;
match String.sub "hello" 0 12 with
  | exception Invalid_argument str
  | str -> str;;
match String.sub "hello" 0 12 with
  | exception Invalid_argument str -> str
  | exception Failure str -> str
  | str -> str;;
</oc-eval>
</warning>
</since-version>

</subsection>
<subsection id="exc:exos" title="Exercice">
<exercice id="exc:exercice" title="try_finalize">
<p>
Ecrire une fonction <ml>try_finalize</ml> spécifiée de la façon suivante:
<ml>try_finalize f x g y</ml> applique la fonction <ml>f</ml> à la valeur <ml>x</ml>.
</p>
<ul>
<li>si une exception est levée, alors on évalue <ml>g y</ml> et on relève ensuite l'exception,</li>
<li>si aucune exception n'est levée, on évalue aussi <ml>g y</ml> et on retourne la valeur
retournée par <ml>f x</ml>.</li>
<li>si une exception est levée par <ml>g y</ml>, cette exception est levée par
la fonction <ml>try_finalize</ml>.</li>
</ul>
<solution>
<oc-eval toplevel="true" error-exc="false"><![CDATA[
let try_finalize f x g y =
  let v = try f x with exn -> ignore(g y); raise exn in
  ignore(g y);
  v;;
try_finalize (fun x -> x * 2) 21 print_endline "application de g a y";;
try_finalize (fun x -> 1 / x) 0 print_endline "application de g a y";;
]]></oc-eval>
</solution>
</exercice>
</subsection>
</section>

<section id="termrec" title="Récursivité terminale">
<p>
La programmation fonctionnelle conduit souvent à écrire des fonctions récursives.
Il existe deux types de récursivités: terminale et non-terminale. Illustrons cette
différence sur un exemple, la fonction de map sur les listes.
</p>
<p>
Voici une première version, récursive non-terminale:
</p>
<oc-eval toplevel="true" session="stack"><![CDATA[
let rec map_nt f = function
  [] -> []
| h::q -> (f h) :: (map_nt f q);;
map_nt ((+) 1) [ 1 ; 2 ; 3 ; 4 ];;
]]></oc-eval>
<p>
La fonction <ml>map_nt</ml> effectue bien le calcul demandé, mais présente un
risque de débordement de pile dans le cas de grandes listes:
</p>
<oc-eval toplevel="true" session="stack" error-exc="false"><![CDATA[
let big_list =
  let rec build n acc =
    if n < 1_000_000 then build (n+1) (n::acc) else acc
  in
  build 0 [];;
try map_nt ((+) 1) big_list
with Stack_overflow -> failwith "Debordement!";;
]]></oc-eval>
<p>
Que se passe-t-il ? Notre fonction <ml>map_nt</ml> fonctionne par cas sur la structure
de la liste en paramètre:
</p>
<ul>
<li>soit la liste est vide, la fonction retourne donc la liste vide,</li>
<li>soit la liste n'est pas vide, dans ce cas la fonction crée une nouvelle
liste composée de l'application de <ml>f</ml> à la tête de la liste, et de l'application
récursive de <ml>map_nt</ml> à la queue de la liste. Cette opération de création de
 la nouvelle liste nécessite le calcul de la nouvelle tête de liste et de la nouvelle
 queue de liste. Ensuite seulement la nouvelle liste est créée et retournée.
 De ce fait, les appels récursifs s'empilent jusqu'au débordement de la pile d'appel.
 Cette fonction est dire récursive non-terminale car il reste du calcul à effectuer
 avec la valeur retournée par l'appel récursif.
 </li>
</ul>
<p>
Voyons maintenant une autre définition, cette fois récursive terminale:
</p>
<oc-eval toplevel="true" session="stack"><![CDATA[
let map f l =
  let rec iter acc = function
    [] -> List.rev acc
  | h::q -> iter ((f h) :: acc) q
  in
  iter [] l;;
map string_of_int big_list;;
]]></oc-eval>
<p>
Notre fonction <ml>map</ml> n'est plus récursive mais se contente
de définir et d'appeler une autre fonction <ml>iter</ml> qui, elle, est
récursive terminale. Cette fonction <ml>iter</ml> prend en paramètre un
accumulateur, ce qui permet, lors de l'appel récursif, d'avoir déjà
effectué la création de la nouvelle liste composée de la nouvelle tête
(<ml>f h</ml>) et du reste de la nouvelle liste déjà calculé (<ml>acc</ml>).
</p>
<p>
Cette façon de procéder donne une liste en ordre inverse, d'où l'appel
à <ml>List.rev</ml> pour retourner l'accumulateur (la nouvelle liste)
lorsqu'on tombe sur le cas de la liste vide (fin de la liste à traiter).
</p>
<p>
La fonction <ml>iter</ml> est récursive terminale car l'appel récursif
à elle-même est bien le dernier calcul effectué dans le cas où la liste
n'est pas vide.
</p>
<p>
Cependant, c'est l'appel récursif et non la fonction qui est ou non
terminal. Dans l'exemple suivant:
</p>
<oc-eval toplevel="true" session="stack"><![CDATA[
let rec f x =
  if x < 1 then f (x + 1) else 1 + f (x - 1);;
]]></oc-eval>
<p>
la fonction <ml>f</ml> est récursive et s'appelle à deux endroits.
Le premier appel récursif (<ml>f (x + 1)</ml>) est bien terminal. Par
contre, le second (<ml>f (x - 1)</ml>) ne l'est pas, car la valeur de
retour de cet appel sera additionnée à 1. On ne peut donc pas parler
de fonction récursive terminale mais d'un appel terminal et d'un
appel non terminal.
</p>
<p>
Les appels récursifs terminaux sont compilés de façon efficace
(avec des sauts plutôt qu'en utilisant la pile) par
le compilateur: au lieu de faire augmenter la taille de la pile,
l'appel récursif est placé au même endroit que l'appel original, ce qui
donne un gain de temps pour retourner la valeur finale (pas besoin
de dépiler des milliers d'appels récursifs) et un gain de place (la pile
n'augmente pas de taille). Nous avons donc pu appliquer notre fonction
sur <ml>big_list</ml>.
</p>
<warning id="warningrecter" title="Exceptions et récursivité terminale">
<p>
L'utilisation de constructions <ml>try ... with</ml> pour la gestion des exceptions
peut faire d'une fonction récursive terminale une fonction récursive non-terminale.
Supposons que nous voulions modifier notre fonction <ml>map</ml> pour, en cas
d'exception <ml>Failure</ml> lors de l'application de <ml>f</ml> à un élement de la liste,
conserver la valeur initiale de l'élément. Nous pouvons tenter la définition
suivante:
</p>
<oc-eval id="safemap" toplevel="true" session="stack" error-exc="false"><![CDATA[
let safe_map f l =
  let rec iter acc = function
    [] -> List.rev acc
  | h::q ->
    try iter ((f h) :: acc) q
    with Failure _ -> iter (h :: acc) q
  in
  iter [] l
;;
safe_map ((+) 1) big_list;;
]]></oc-eval>
<p>
La présence du bloc <ml>try ... with</ml> en vue de rattraper l'exception <ml>Failure</ml>
ne permet plus au compilateur d'optimiser les appels récursifs sur la pile. En effet,
l'appel récursif n'est plus forcément le dernier calcul effectué, car s'il lève
une exception, il faudra la filtrer dans ce contexte et non dans celui de
l'appel récursif.
On écrira donc plutôt:
</p>
<oc-eval id="safemap2" toplevel="true" session="stack"><![CDATA[
let safe_map f l =
  let rec iter acc = function
    [] -> List.rev acc
  | h::q ->
    let v = try f h with Failure _ -> h in
    iter (v :: acc) q
  in
  iter [] l
;;
safe_map ((+) 1) big_list;;
]]></oc-eval>
<p>
Dans ce cas, l'appel récursif redevient le dernier calcul, le rattrapage d'exception
étant limité au calcul de <ml>f h</ml>.
</p>
</warning>
<p>
Un appel peut être terminal même s'il ne s'agit pas d'un appel récursif.
Le compilateur pourra faire des optimisations dans ce cas aussi.
</p>
<p>
L'option <icode>-annot</icode> des compilateurs OCaml génère, à la compilation
d'un fichier d'implémentation <icode>foo.ml</icode>, un fichier <icode>foo.annot</icode>
contenant diverses informations, notamment les types inférés pour chaque
expression et, depuis la version 3.11.0, une indication de terminalité
pour chaque appel de fonction: <icode>tail</icode> indiquera que l'appel est
terminal, tandis que <icode>stack</icode> indiquera que l'appel se fera sur la pile.
</p>
</section>
</contents>
</module>
